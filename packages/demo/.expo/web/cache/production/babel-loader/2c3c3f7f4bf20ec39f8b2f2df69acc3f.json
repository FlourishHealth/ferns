{"ast":null,"code":"import bytesToUuid from'./bytesToUuid';function uuidToBytes(uuid){var bytes=[];uuid.replace(/[a-fA-F0-9]{2}/g,function(hex){bytes.push(parseInt(hex,16));return'';});return bytes;}function stringToBytes(str){str=unescape(encodeURIComponent(str));var bytes=new Array(str.length);for(var i=0;i<str.length;i++){bytes[i]=str.charCodeAt(i);}return bytes;}export default function(name,version,hashfunc){var generateUUID=function generateUUID(value,namespace,buf,offset){var off=buf&&offset||0;if(typeof value=='string')value=stringToBytes(value);if(typeof namespace=='string')namespace=uuidToBytes(namespace);if(!Array.isArray(value))throw TypeError('value must be an array of bytes');if(!Array.isArray(namespace)||namespace.length!==16)throw TypeError('namespace must be uuid string or an Array of 16 byte values');var bytes=hashfunc(namespace.concat(value));bytes[6]=bytes[6]&0x0f|version;bytes[8]=bytes[8]&0x3f|0x80;if(buf){for(var idx=0;idx<16;++idx){buf[off+idx]=bytes[idx];}}return bytesToUuid(bytes);};try{generateUUID.name=name;}catch(_unused){}generateUUID.DNS='6ba7b810-9dad-11d1-80b4-00c04fd430c8';generateUUID.URL='6ba7b811-9dad-11d1-80b4-00c04fd430c8';return generateUUID;}","map":{"version":3,"sources":["../../../src/uuid/lib/v35.ts"],"names":[],"mappings":"AAAA,MAAO,CAAA,WAAW,KAAM,eAAe,CAEvC,QAAS,CAAA,WAAW,CAAC,IAAY,CAAA,CAE/B,GAAM,CAAA,KAAK,CAAa,EAAE,CAC1B,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAE,SAAC,GAAW,CAAI,CAC9C,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,EAAE,CAAC,CAAC,CAC7B,MAAO,EAAE,CACX,CAAC,CAAC,CAEF,MAAO,CAAA,KAAK,CACd,CAEA,QAAS,CAAA,aAAa,CAAC,GAAW,CAAA,CAChC,GAAG,CAAG,QAAQ,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,CACvC,GAAM,CAAA,KAAK,CAAa,GAAI,CAAA,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAC7C,IAAK,GAAI,CAAA,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,GAAG,CAAC,MAAM,CAAE,CAAC,EAAE,CAAE,CACnC,KAAK,CAAC,CAAC,CAAC,CAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAC7B,CACD,MAAO,CAAA,KAAK,CACd,CAEA,cAAc,UACZ,IAAY,CACZ,OAAe,CACf,QAAgD,CAAA,CAEhD,GAAM,CAAA,YAAY,CAAG,QAAf,CAAA,YAAY,CAChB,KAAwB,CACxB,SAA4B,CAC5B,GAAc,CACd,MAAe,CAAA,CAEf,GAAM,CAAA,GAAG,CAAI,GAAG,EAAI,MAAM,EAAK,CAAC,CAEhC,GAAI,MAAO,CAAA,KAAK,EAAI,QAAQ,CAAE,KAAK,CAAG,aAAa,CAAC,KAAK,CAAC,CAC1D,GAAI,MAAO,CAAA,SAAS,EAAI,QAAQ,CAAE,SAAS,CAAG,WAAW,CAAC,SAAS,CAAC,CAEpE,GAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAE,KAAM,CAAA,SAAS,CAAC,iCAAiC,CAAC,CAC7E,GAAI,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAI,SAAS,CAAC,MAAM,GAAK,EAAE,CACtD,KAAM,CAAA,SAAS,CAAC,6DAA6D,CAAC,CAGhF,GAAM,CAAA,KAAK,CAAG,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAC/C,KAAK,CAAC,CAAC,CAAC,CAAI,KAAK,CAAC,CAAC,CAAC,CAAG,IAAI,CAAI,OAAO,CACtC,KAAK,CAAC,CAAC,CAAC,CAAI,KAAK,CAAC,CAAC,CAAC,CAAG,IAAI,CAAI,IAAI,CAEnC,GAAI,GAAG,CAAE,CACP,IAAK,GAAI,CAAA,GAAG,CAAG,CAAC,CAAE,GAAG,CAAG,EAAE,CAAE,EAAE,GAAG,CAAE,CACjC,GAAG,CAAC,GAAG,CAAG,GAAG,CAAC,CAAG,KAAK,CAAC,GAAG,CAAC,CAC5B,CACF,CAED,MAAO,CAAA,WAAW,CAAC,KAAK,CAAC,CAC3B,CAAC,CAGD,GAAI,CACF,YAAY,CAAC,IAAI,CAAG,IAAI,CACzB,CAAC,MAAA,OAAA,CAAM,CAAA,CAGR,YAAY,CAAC,GAAG,CAAG,sCAAsC,CACzD,YAAY,CAAC,GAAG,CAAG,sCAAsC,CAEzD,MAAO,CAAA,YAAY,CACrB","sourcesContent":["import bytesToUuid from './bytesToUuid';\n\nfunction uuidToBytes(uuid: string) {\n  // Note: We assume we're being passed a valid uuid string\n  const bytes: number[] = [];\n  uuid.replace(/[a-fA-F0-9]{2}/g, (hex: string) => {\n    bytes.push(parseInt(hex, 16));\n    return '';\n  });\n\n  return bytes;\n}\n\nfunction stringToBytes(str: string) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n  const bytes: number[] = new Array(str.length);\n  for (let i = 0; i < str.length; i++) {\n    bytes[i] = str.charCodeAt(i);\n  }\n  return bytes;\n}\n\nexport default function (\n  name: string,\n  version: number,\n  hashfunc: (bytes: number[] | string) => number[]\n) {\n  const generateUUID = function (\n    value: number[] | string,\n    namespace: number[] | string,\n    buf?: number[],\n    offset?: number\n  ): string {\n    const off = (buf && offset) || 0;\n\n    if (typeof value == 'string') value = stringToBytes(value);\n    if (typeof namespace == 'string') namespace = uuidToBytes(namespace);\n\n    if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');\n    if (!Array.isArray(namespace) || namespace.length !== 16)\n      throw TypeError('namespace must be uuid string or an Array of 16 byte values');\n\n    // Per 4.3\n    const bytes = hashfunc(namespace.concat(value));\n    bytes[6] = (bytes[6] & 0x0f) | version;\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    if (buf) {\n      for (let idx = 0; idx < 16; ++idx) {\n        buf[off + idx] = bytes[idx];\n      }\n    }\n\n    return bytesToUuid(bytes);\n  };\n\n  // Function#name is not settable on some platforms (#270)\n  try {\n    generateUUID.name = name;\n  } catch {}\n\n  // Pre-defined namespaces, per Appendix C\n  generateUUID.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n  generateUUID.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n\n  return generateUUID;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}