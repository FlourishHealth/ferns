{"ast":null,"code":"'use strict';import{useRef}from'react';import WorkletEventHandler from'../WorkletEventHandler';export function useEvent(handler){var eventNames=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var rebuild=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var initRef=useRef(null);if(initRef.current===null){initRef.current=new WorkletEventHandler(handler,eventNames);}else if(rebuild){initRef.current.updateWorklet(handler);}return initRef;}","map":{"version":3,"sources":["useEvent.ts"],"names":["useRef","WorkletEventHandler","useEvent","handler","eventNames","rebuild","initRef","current","updateWorklet"],"mappings":"AAAA,YAAY,CAEZ,OAASA,MAAM,KAAQ,OAAO,CAC9B,MAAOC,CAAAA,mBAAmB,KAAM,wBAAwB,CA2CxD,MAAO,SAASC,CAAAA,QAAQA,CACtBC,OAAmE,CAGtC,CAAA,GAF7BC,CAAAA,UAAoB,CAAA,SAAA,CAAA,MAAA,CAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAG,EAAE,CAAA,GACzBC,CAAAA,OAAO,CAAA,SAAA,CAAA,MAAA,CAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAG,KAAK,CAEf,GAAMC,CAAAA,OAAO,CAAGN,MAAM,CAAoC,IAAI,CAAC,CAC/D,GAAIM,OAAO,CAACC,OAAO,GAAK,IAAI,CAAE,CAC5BD,OAAO,CAACC,OAAO,CAAG,GAAIN,CAAAA,mBAAmB,CAAQE,OAAO,CAAEC,UAAU,CAAC,CACvE,CAAC,IAAM,IAAIC,OAAO,CAAE,CAClBC,OAAO,CAACC,OAAO,CAACC,aAAa,CAACL,OAAO,CAAC,CACxC,CAGA,MAAOG,CAAAA,OAAO,CAChB","sourcesContent":["'use strict';\nimport type { MutableRefObject } from 'react';\nimport { useRef } from 'react';\nimport WorkletEventHandler from '../WorkletEventHandler';\nimport type { ReanimatedEvent } from './commonTypes';\n\n/**\n * Worklet to provide as an argument to `useEvent` hook.\n */\nexport type EventHandler<\n  Event extends object,\n  Context extends Record<string, unknown> = never\n> = (event: ReanimatedEvent<Event>, context?: Context) => void;\n\nexport type EventHandlerProcessed<\n  Event extends object,\n  Context extends Record<string, unknown> = never\n> = (event: Event, context?: Context) => void;\n\nexport type EventHandlerInternal<Event extends object> = MutableRefObject<\n  WorkletEventHandler<Event>\n>;\n\n/**\n * Lets you run a function whenever a specified native event occurs.\n *\n * @param handler - A function that receives an event object with event data - {@link EventHandler}.\n * @param eventNames - An array of event names the `handler` callback will react to.\n * @param rebuild - Whether the event handler should be rebuilt. Defaults to `false`.\n * @returns A function that will be called when the event occurs - {@link EventHandlerProcessed}.\n * @see https://docs.swmansion.com/react-native-reanimated/docs/advanced/useEvent\n */\n// @ts-expect-error This overload is required by our API.\n// We don't know which properites of a component that is made into\n// an AnimatedComponent are event handlers and we don't want to force the user to define it.\n// Therefore we disguise `useEvent` return type as a simple function and we handle\n// it being a React Ref in `createAnimatedComponent`.\nexport function useEvent<\n  Event extends object,\n  Context extends Record<string, unknown> = never\n>(\n  handler: EventHandler<Event, Context>,\n  eventNames?: string[],\n  rebuild?: boolean\n): EventHandlerProcessed<Event, Context>;\n\nexport function useEvent<Event extends object, Context = never>(\n  handler: (event: ReanimatedEvent<Event>, context?: Context) => void,\n  eventNames: string[] = [],\n  rebuild = false\n): EventHandlerInternal<Event> {\n  const initRef = useRef<WorkletEventHandler<Event> | null>(null);\n  if (initRef.current === null) {\n    initRef.current = new WorkletEventHandler<Event>(handler, eventNames);\n  } else if (rebuild) {\n    initRef.current.updateWorklet(handler);\n  }\n\n  // We cast it since we don't want to expose initial null value outside.\n  return initRef as EventHandlerInternal<Event>;\n}\n"]},"metadata":{},"sourceType":"module"}