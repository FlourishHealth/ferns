{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}import Platform from\"react-native-web/dist/exports/Platform\";import findNodeHandleRN from\"react-native-web/dist/exports/findNodeHandle\";import{handlerIDToTag}from'./handlersRegistry';import{toArray}from'../utils';import RNGestureHandlerModule from'../RNGestureHandlerModule';import{ghQueueMicrotask}from'../ghQueueMicrotask';var commonProps=['id','enabled','shouldCancelWhenOutside','hitSlop','cancelsTouchesInView','userSelect','activeCursor'];var componentInteractionProps=['waitFor','simultaneousHandlers','blocksHandlers'];export var baseGestureHandlerProps=[].concat(commonProps,componentInteractionProps,['onBegan','onFailed','onCancelled','onActivated','onEnded','onGestureEvent','onHandlerStateChange']);export var baseGestureHandlerWithMonitorProps=[].concat(commonProps,['needsPointerData','manualActivation']);function isConfigParam(param,name){return param!==undefined&&(param!==Object(param)||!('__isNative'in param))&&name!=='onHandlerStateChange'&&name!=='onGestureEvent';}export function filterConfig(props,validProps){var defaults=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var filteredConfig=_objectSpread({},defaults);for(var key of validProps){var value=props[key];if(isConfigParam(value,key)){if(key==='simultaneousHandlers'||key==='waitFor'){value=transformIntoHandlerTags(props[key]);}else if(key==='hitSlop'&&typeof value!=='object'){value={top:value,left:value,bottom:value,right:value};}filteredConfig[key]=value;}}return filteredConfig;}function transformIntoHandlerTags(handlerIDs){handlerIDs=toArray(handlerIDs);if(\"web\"==='web'){return handlerIDs.map(function(_ref){var current=_ref.current;return current;}).filter(function(handle){return handle;});}return handlerIDs.map(function(handlerID){var _handlerID$current;return handlerIDToTag[handlerID]||((_handlerID$current=handlerID.current)===null||_handlerID$current===void 0?void 0:_handlerID$current.handlerTag)||-1;}).filter(function(handlerTag){return handlerTag>0;});}export function findNodeHandle(node){if(\"web\"==='web'){return node;}return findNodeHandleRN(node);}var flushOperationsScheduled=false;export function scheduleFlushOperations(){if(!flushOperationsScheduled){flushOperationsScheduled=true;ghQueueMicrotask(function(){RNGestureHandlerModule.flushOperations();flushOperationsScheduled=false;});}}","map":{"version":3,"sources":["gestureHandlerCommon.ts"],"names":["handlerIDToTag","toArray","RNGestureHandlerModule","ghQueueMicrotask","commonProps","componentInteractionProps","baseGestureHandlerProps","baseGestureHandlerWithMonitorProps","isConfigParam","param","name","undefined","Object","filterConfig","props","validProps","defaults","filteredConfig","key","value","transformIntoHandlerTags","top","left","bottom","right","handlerIDs","Platform","map","current","filter","handle","handlerID","handlerTag","findNodeHandle","node","findNodeHandleRN","flushOperationsScheduled","scheduleFlushOperations","flushOperations"],"mappings":"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","sourcesContent":["// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\nimport * as React from 'react';\nimport { Platform, findNodeHandle as findNodeHandleRN } from 'react-native';\n\nimport { State } from '../State';\nimport { TouchEventType } from '../TouchEventType';\nimport { ValueOf } from '../typeUtils';\nimport { handlerIDToTag } from './handlersRegistry';\nimport { toArray } from '../utils';\nimport RNGestureHandlerModule from '../RNGestureHandlerModule';\nimport { ghQueueMicrotask } from '../ghQueueMicrotask';\n\nconst commonProps = [\n  'id',\n  'enabled',\n  'shouldCancelWhenOutside',\n  'hitSlop',\n  'cancelsTouchesInView',\n  'userSelect',\n  'activeCursor',\n] as const;\n\nconst componentInteractionProps = [\n  'waitFor',\n  'simultaneousHandlers',\n  'blocksHandlers',\n] as const;\n\nexport const baseGestureHandlerProps = [\n  ...commonProps,\n  ...componentInteractionProps,\n  'onBegan',\n  'onFailed',\n  'onCancelled',\n  'onActivated',\n  'onEnded',\n  'onGestureEvent',\n  'onHandlerStateChange',\n] as const;\n\nexport const baseGestureHandlerWithMonitorProps = [\n  ...commonProps,\n  'needsPointerData',\n  'manualActivation',\n];\n\nexport interface GestureEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n}\nexport interface HandlerStateChangeEventPayload extends GestureEventPayload {\n  oldState: ValueOf<typeof State>;\n}\n\nexport type HitSlop =\n  | number\n  | Partial<\n      Record<\n        'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\n        number\n      >\n    >\n  | Record<'width' | 'left', number>\n  | Record<'width' | 'right', number>\n  | Record<'height' | 'top', number>\n  | Record<'height' | 'bottom', number>;\n\nexport type UserSelect = 'none' | 'auto' | 'text';\nexport type ActiveCursor =\n  | 'auto'\n  | 'default'\n  | 'none'\n  | 'context-menu'\n  | 'help'\n  | 'pointer'\n  | 'progress'\n  | 'wait'\n  | 'cell'\n  | 'crosshair'\n  | 'text'\n  | 'vertical-text'\n  | 'alias'\n  | 'copy'\n  | 'move'\n  | 'no-drop'\n  | 'not-allowed'\n  | 'grab'\n  | 'grabbing'\n  | 'e-resize'\n  | 'n-resize'\n  | 'ne-resize'\n  | 'nw-resize'\n  | 's-resize'\n  | 'se-resize'\n  | 'sw-resize'\n  | 'w-resize'\n  | 'ew-resize'\n  | 'ns-resize'\n  | 'nesw-resize'\n  | 'nwse-resize'\n  | 'col-resize'\n  | 'row-resize'\n  | 'all-scroll'\n  | 'zoom-in'\n  | 'zoom-out';\n\n//TODO(TS) events in handlers\n\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\n}\nexport interface HandlerStateChangeEvent<\n  ExtraEventPayloadT = Record<string, unknown>\n> {\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\n}\n\nexport type TouchData = {\n  id: number;\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport type GestureTouchEvent = {\n  handlerTag: number;\n  numberOfTouches: number;\n  state: ValueOf<typeof State>;\n  eventType: TouchEventType;\n  allTouches: TouchData[];\n  changedTouches: TouchData[];\n};\n\nexport type GestureUpdateEvent<GestureEventPayloadT = Record<string, unknown>> =\n  GestureEventPayload & GestureEventPayloadT;\n\nexport type GestureStateChangeEvent<\n  GestureStateChangeEventPayloadT = Record<string, unknown>\n> = HandlerStateChangeEventPayload & GestureStateChangeEventPayloadT;\n\nexport type CommonGestureConfig = {\n  enabled?: boolean;\n  shouldCancelWhenOutside?: boolean;\n  hitSlop?: HitSlop;\n  userSelect?: UserSelect;\n  activeCursor?: ActiveCursor;\n};\n\n// Events payloads are types instead of interfaces due to TS limitation.\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\nexport type BaseGestureHandlerProps<\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\n> = CommonGestureConfig & {\n  id?: string;\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\n  blocksHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\n  testID?: string;\n  cancelsTouchesInView?: boolean;\n  // TODO(TS) - fix event types\n  onBegan?: (event: HandlerStateChangeEvent) => void;\n  onFailed?: (event: HandlerStateChangeEvent) => void;\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\n  onActivated?: (event: HandlerStateChangeEvent) => void;\n  onEnded?: (event: HandlerStateChangeEvent) => void;\n\n  //TODO(TS) consider using NativeSyntheticEvent\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\n  onHandlerStateChange?: (\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\n  ) => void;\n  // implicit `children` prop has been removed in @types/react^18.0.0\n  children?: React.ReactNode;\n};\n\nfunction isConfigParam(param: unknown, name: string) {\n  // param !== Object(param) returns false if `param` is a function\n  // or an object and returns true if `param` is null\n  return (\n    param !== undefined &&\n    (param !== Object(param) ||\n      !('__isNative' in (param as Record<string, unknown>))) &&\n    name !== 'onHandlerStateChange' &&\n    name !== 'onGestureEvent'\n  );\n}\n\nexport function filterConfig(\n  props: Record<string, unknown>,\n  validProps: string[],\n  defaults: Record<string, unknown> = {}\n) {\n  const filteredConfig = { ...defaults };\n  for (const key of validProps) {\n    let value = props[key];\n    if (isConfigParam(value, key)) {\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop' && typeof value !== 'object') {\n        value = { top: value, left: value, bottom: value, right: value };\n      }\n      filteredConfig[key] = value;\n    }\n  }\n  return filteredConfig;\n}\n\nfunction transformIntoHandlerTags(handlerIDs: any) {\n  handlerIDs = toArray(handlerIDs);\n\n  if (Platform.OS === 'web') {\n    return handlerIDs\n      .map(({ current }: { current: any }) => current)\n      .filter((handle: any) => handle);\n  }\n  // converts handler string IDs into their numeric tags\n  return handlerIDs\n    .map(\n      (handlerID: any) =>\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\n    )\n    .filter((handlerTag: number) => handlerTag > 0);\n}\n\nexport function findNodeHandle(\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\n  if (Platform.OS === 'web') {\n    return node;\n  }\n  return findNodeHandleRN(node);\n}\n\nlet flushOperationsScheduled = false;\n\nexport function scheduleFlushOperations() {\n  if (!flushOperationsScheduled) {\n    flushOperationsScheduled = true;\n    ghQueueMicrotask(() => {\n      RNGestureHandlerModule.flushOperations();\n\n      flushOperationsScheduled = false;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}