{"ast":null,"code":"import{Asset}from'expo-asset';import{CodedError}from'expo-modules-core';import ExpoFontLoader from'./ExpoFontLoader';import{FontDisplay}from'./Font.types';function uriFromFontSource(asset){if(typeof asset==='string'){return asset||null;}else if(typeof asset==='object'){return asset.uri||asset.localUri||asset.default||null;}else if(typeof asset==='number'){return uriFromFontSource(Asset.fromModule(asset));}return null;}function displayFromFontSource(asset){return asset.display||FontDisplay.AUTO;}export function fontFamilyNeedsScoping(name){return false;}export function getAssetForSource(source){var uri=uriFromFontSource(source);var display=displayFromFontSource(source);if(!uri||typeof uri!=='string'){throwInvalidSourceError(uri);}return{uri:uri,display:display};}function throwInvalidSourceError(source){var type=typeof source;if(type==='object')type=JSON.stringify(source,null,2);throw new CodedError(`ERR_FONT_SOURCE`,`Expected font asset of type \\`string | FontResource | Asset\\` instead got: ${type}`);}export function loadSingleFontAsync(name,input){if(typeof input!=='object'||typeof input.uri!=='string'||input.downloadAsync){throwInvalidSourceError(input);}try{return ExpoFontLoader.loadAsync(name,input);}catch(_unused){}return Promise.resolve();}export function getNativeFontName(name){return name;}","map":{"version":3,"sources":["../src/FontLoader.web.ts"],"names":[],"mappings":"AAAA,OAAS,KAAK,KAAQ,YAAY,CAClC,OAAS,UAAU,KAAQ,mBAAmB,CAE9C,MAAO,CAAA,cAAc,KAAM,kBAAkB,CAC7C,OAAmC,WAAW,KAAQ,cAAc,CAEpE,QAAS,CAAA,iBAAiB,CAAC,KAAU,CAAA,CACnC,GAAI,MAAO,CAAA,KAAK,GAAK,QAAQ,CAAE,CAC7B,MAAO,CAAA,KAAK,EAAI,IAAI,C,CACrB,IAAM,IAAI,MAAO,CAAA,KAAK,GAAK,QAAQ,CAAE,CACpC,MAAO,CAAA,KAAK,CAAC,GAAG,EAAI,KAAK,CAAC,QAAQ,EAAI,KAAK,CAAC,OAAO,EAAI,IAAI,C,CAC5D,IAAM,IAAI,MAAO,CAAA,KAAK,GAAK,QAAQ,CAAE,CACpC,MAAO,CAAA,iBAAiB,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAClD,CACD,MAAO,KAAI,CACb,CAEA,QAAS,CAAA,qBAAqB,CAAC,KAAU,CAAA,CACvC,MAAO,CAAA,KAAK,CAAC,OAAO,EAAI,WAAW,CAAC,IAAI,CAC1C,CAEA,MAAM,SAAU,CAAA,sBAAsB,CAAC,IAAY,CAAA,CACjD,MAAO,MAAK,CACd,CAEA,MAAM,SAAU,CAAA,iBAAiB,CAAC,MAAkB,CAAA,CAClD,GAAM,CAAA,GAAG,CAAG,iBAAiB,CAAC,MAAM,CAAC,CACrC,GAAM,CAAA,OAAO,CAAG,qBAAqB,CAAC,MAAM,CAAC,CAE7C,GAAI,CAAC,GAAG,EAAI,MAAO,CAAA,GAAG,GAAK,QAAQ,CAAE,CACnC,uBAAuB,CAAC,GAAG,CAAC,CAC7B,CAED,MAAO,CACL,GAAG,CAAE,GAAI,CACT,OAAO,CAAP,O,CACD,CACH,CAEA,QAAS,CAAA,uBAAuB,CAAC,MAAW,CAAA,CAC1C,GAAI,CAAA,IAAI,CAAW,MAAO,CAAA,MAAM,CAChC,GAAI,IAAI,GAAK,QAAQ,CAAE,IAAI,CAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAE,IAAI,CAAE,CAAC,CAAC,CAC7D,KAAM,IAAI,CAAA,UAAU,CAClB,iBAAiB,CACjB,8EAA8E,IAAI,EAAE,CACrF,CACH,CAGA,MAAM,SAAU,CAAA,mBAAmB,CAAC,IAAY,CAAE,KAA2B,CAAA,CAC3E,GAAI,MAAO,CAAA,KAAK,GAAK,QAAQ,EAAI,MAAO,CAAA,KAAK,CAAC,GAAG,GAAK,QAAQ,EAAK,KAAa,CAAC,aAAa,CAAE,CAC9F,uBAAuB,CAAC,KAAK,CAAC,CAC/B,CAED,GAAI,CACF,MAAO,CAAA,cAAc,CAAC,SAAS,CAAC,IAAI,CAAE,KAAK,CAAC,CAC7C,CAAC,MAAA,OAAA,CAAM,CAEP,CAED,MAAO,CAAA,OAAO,CAAC,OAAO,CAAA,CAAE,CAC1B,CAEA,MAAM,SAAU,CAAA,iBAAiB,CAAC,IAAY,CAAA,CAC5C,MAAO,CAAA,IAAI,CACb","sourcesContent":["import { Asset } from 'expo-asset';\nimport { CodedError } from 'expo-modules-core';\n\nimport ExpoFontLoader from './ExpoFontLoader';\nimport { FontResource, FontSource, FontDisplay } from './Font.types';\n\nfunction uriFromFontSource(asset: any): string | null {\n  if (typeof asset === 'string') {\n    return asset || null;\n  } else if (typeof asset === 'object') {\n    return asset.uri || asset.localUri || asset.default || null;\n  } else if (typeof asset === 'number') {\n    return uriFromFontSource(Asset.fromModule(asset));\n  }\n  return null;\n}\n\nfunction displayFromFontSource(asset: any): FontDisplay | undefined {\n  return asset.display || FontDisplay.AUTO;\n}\n\nexport function fontFamilyNeedsScoping(name: string): boolean {\n  return false;\n}\n\nexport function getAssetForSource(source: FontSource): Asset | FontResource {\n  const uri = uriFromFontSource(source);\n  const display = displayFromFontSource(source);\n\n  if (!uri || typeof uri !== 'string') {\n    throwInvalidSourceError(uri);\n  }\n\n  return {\n    uri: uri!,\n    display,\n  };\n}\n\nfunction throwInvalidSourceError(source: any): never {\n  let type: string = typeof source;\n  if (type === 'object') type = JSON.stringify(source, null, 2);\n  throw new CodedError(\n    `ERR_FONT_SOURCE`,\n    `Expected font asset of type \\`string | FontResource | Asset\\` instead got: ${type}`\n  );\n}\n\n// NOTE(EvanBacon): No async keyword!\nexport function loadSingleFontAsync(name: string, input: Asset | FontResource): Promise<void> {\n  if (typeof input !== 'object' || typeof input.uri !== 'string' || (input as any).downloadAsync) {\n    throwInvalidSourceError(input);\n  }\n\n  try {\n    return ExpoFontLoader.loadAsync(name, input);\n  } catch {\n    // No-op.\n  }\n\n  return Promise.resolve();\n}\n\nexport function getNativeFontName(name: string): string {\n  return name;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}