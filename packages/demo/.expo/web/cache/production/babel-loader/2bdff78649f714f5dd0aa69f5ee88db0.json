{"ast":null,"code":"import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";export function base64toBlob(base64Data,contentType){contentType=contentType||'';var sliceSize=1024;var byteCharacters=atob(base64Data);var bytesLength=byteCharacters.length;var slicesCount=Math.ceil(bytesLength/sliceSize);var byteArrays=new Array(slicesCount);for(var sliceIndex=0;sliceIndex<slicesCount;++sliceIndex){var begin=sliceIndex*sliceSize;var end=Math.min(begin+sliceSize,bytesLength);var bytes=new Array(end-begin);for(var offset=begin,i=0;offset<end;++i,++offset){bytes[i]=byteCharacters[offset].charCodeAt(0);}byteArrays[sliceIndex]=new Uint8Array(bytes);}return new Blob(byteArrays,{type:contentType});}export function blobToBase64Async(blob){return new Promise(function(resolve,_){var reader=new FileReader();reader.onloadend=function(){return resolve(reader.result);};reader.readAsDataURL(blob);});}export function htmlToPlainText(html){var tempDivElement=document.createElement('div');tempDivElement.innerHTML=html;return tempDivElement.textContent||tempDivElement.innerText||'';}export function getImageSizeFromBlobAsync(blob){return new Promise(function(resolve,_){var blobUrl=URL.createObjectURL(blob);var img=document.createElement('img');img.src=blobUrl;img.onload=function(){resolve({width:img.width,height:img.height});};});}export function findImageInClipboardAsync(_x){return _findImageInClipboardAsync.apply(this,arguments);}function _findImageInClipboardAsync(){_findImageInClipboardAsync=_asyncToGenerator(function*(items){for(var clipboardItem of items){if(clipboardItem.types.some(function(type){return type==='image/png';})){return yield clipboardItem.getType('image/png');}if(clipboardItem.types.some(function(type){return type==='image/jpeg';})){return yield clipboardItem.getType('image/jpeg');}}return null;});return _findImageInClipboardAsync.apply(this,arguments);}export function findHtmlInClipboardAsync(_x2){return _findHtmlInClipboardAsync.apply(this,arguments);}function _findHtmlInClipboardAsync(){_findHtmlInClipboardAsync=_asyncToGenerator(function*(items){for(var clipboardItem of items){if(clipboardItem.types.some(function(type){return type==='text/html';})){return yield clipboardItem.getType('text/html');}}return null;});return _findHtmlInClipboardAsync.apply(this,arguments);}export function isClipboardPermissionDeniedAsync(){return _isClipboardPermissionDeniedAsync.apply(this,arguments);}function _isClipboardPermissionDeniedAsync(){_isClipboardPermissionDeniedAsync=_asyncToGenerator(function*(){var queryOpts={name:'clipboard-read'};var permissionStatus=yield navigator.permissions.query(queryOpts);return permissionStatus.state==='denied';});return _isClipboardPermissionDeniedAsync.apply(this,arguments);}","map":{"version":3,"sources":["../../src/web/Utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Converts base64-encoded data to a `Blob` object.\n * @see https://stackoverflow.com/a/20151856\n */\nexport function base64toBlob(base64Data: string, contentType: string): Blob {\n  contentType = contentType || '';\n  const sliceSize = 1024;\n  const byteCharacters = atob(base64Data);\n  const bytesLength = byteCharacters.length;\n  const slicesCount = Math.ceil(bytesLength / sliceSize);\n  const byteArrays = new Array(slicesCount);\n\n  for (let sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {\n    const begin = sliceIndex * sliceSize;\n    const end = Math.min(begin + sliceSize, bytesLength);\n\n    const bytes = new Array(end - begin);\n    for (let offset = begin, i = 0; offset < end; ++i, ++offset) {\n      bytes[i] = byteCharacters[offset].charCodeAt(0);\n    }\n    byteArrays[sliceIndex] = new Uint8Array(bytes);\n  }\n  // I cannot use `@ts-expect-error` here because some environments consider this correct:\n  // expo-module build - OK,\n  // expo-module test - error\n  // @ts-ignore `Blob` from `lib.dom.d.ts` and the one from `@types/react-native` differ somehow\n  return new Blob(byteArrays, { type: contentType });\n}\n\n/**\n * Converts blob to base64-encoded string with Data-URL prefix.\n */\nexport function blobToBase64Async(blob: Blob): Promise<string> {\n  return new Promise((resolve, _) => {\n    const reader = new FileReader();\n    reader.onloadend = () => resolve(reader.result as string);\n    reader.readAsDataURL(blob);\n  });\n}\n\nexport function htmlToPlainText(html: string) {\n  const tempDivElement = document.createElement('div');\n  tempDivElement.innerHTML = html;\n  return tempDivElement.textContent || tempDivElement.innerText || '';\n}\n\nexport function getImageSizeFromBlobAsync(blob: Blob): Promise<{ width: number; height: number }> {\n  return new Promise((resolve, _) => {\n    const blobUrl = URL.createObjectURL(blob);\n    const img = document.createElement('img');\n    img.src = blobUrl;\n    img.onload = function () {\n      resolve({ width: img.width, height: img.height });\n    };\n  });\n}\n\nexport async function findImageInClipboardAsync(items: ClipboardItems): Promise<Blob | null> {\n  for (const clipboardItem of items) {\n    // first look for png\n    if (clipboardItem.types.some((type) => type === 'image/png')) {\n      return await clipboardItem.getType('image/png');\n    }\n\n    // alternatively, an image might be a jpeg\n    // NOTE: Currently, this is not supported by browsers yet. They only support PNG now\n    if (clipboardItem.types.some((type) => type === 'image/jpeg')) {\n      return await clipboardItem.getType('image/jpeg');\n    }\n  }\n  return null;\n}\n\nexport async function findHtmlInClipboardAsync(items: ClipboardItems): Promise<Blob | null> {\n  for (const clipboardItem of items) {\n    if (clipboardItem.types.some((type) => type === 'text/html')) {\n      return await clipboardItem.getType('text/html');\n    }\n  }\n  return null;\n}\n\nexport async function isClipboardPermissionDeniedAsync(): Promise<boolean> {\n  const queryOpts = { name: 'clipboard-read' as PermissionName };\n  const permissionStatus = await navigator.permissions.query(queryOpts);\n  return permissionStatus.state === 'denied';\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}