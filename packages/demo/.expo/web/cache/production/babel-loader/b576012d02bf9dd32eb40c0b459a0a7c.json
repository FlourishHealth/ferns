{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import{State}from'../../State';import{PointerType}from'../interfaces';import PointerTracker from'./PointerTracker';var GestureHandlerOrchestrator=function(){function GestureHandlerOrchestrator(){_classCallCheck(this,GestureHandlerOrchestrator);_defineProperty(this,\"gestureHandlers\",[]);_defineProperty(this,\"awaitingHandlers\",[]);_defineProperty(this,\"handlingChangeSemaphore\",0);_defineProperty(this,\"activationIndex\",0);}_createClass(GestureHandlerOrchestrator,[{key:\"scheduleFinishedHandlersCleanup\",value:function scheduleFinishedHandlersCleanup(){if(this.handlingChangeSemaphore===0){this.cleanupFinishedHandlers();}}},{key:\"cleanHandler\",value:function cleanHandler(handler){handler.reset();handler.setActive(false);handler.setAwaiting(false);handler.setActivationIndex(Number.MAX_VALUE);}},{key:\"removeHandlerFromOrchestrator\",value:function removeHandlerFromOrchestrator(handler){this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler),1);this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler),1);}},{key:\"cleanupFinishedHandlers\",value:function cleanupFinishedHandlers(){for(var i=this.gestureHandlers.length-1;i>=0;--i){var handler=this.gestureHandlers[i];if(!handler){continue;}if(this.isFinished(handler.getState())&&!handler.isAwaiting()){this.gestureHandlers.splice(i,1);this.cleanHandler(handler);}}}},{key:\"hasOtherHandlerToWaitFor\",value:function hasOtherHandlerToWaitFor(handler){var _this=this;var hasToWait=false;this.gestureHandlers.forEach(function(otherHandler){if(otherHandler&&!_this.isFinished(otherHandler.getState())&&_this.shouldHandlerWaitForOther(handler,otherHandler)){hasToWait=true;return;}});return hasToWait;}},{key:\"tryActivate\",value:function tryActivate(handler){if(this.hasOtherHandlerToWaitFor(handler)){this.addAwaitingHandler(handler);}else if(handler.getState()!==State.CANCELLED&&handler.getState()!==State.FAILED){if(this.shouldActivate(handler)){this.makeActive(handler);}else{switch(handler.getState()){case State.ACTIVE:handler.fail();break;case State.BEGAN:handler.cancel();}}}}},{key:\"shouldActivate\",value:function shouldActivate(handler){for(var otherHandler of this.gestureHandlers){if(this.shouldHandlerBeCancelledBy(handler,otherHandler)){return false;}}return true;}},{key:\"cleanupAwaitingHandlers\",value:function cleanupAwaitingHandlers(handler){for(var i=0;i<this.awaitingHandlers.length;++i){if(!this.awaitingHandlers[i].isAwaiting()&&this.shouldHandlerWaitForOther(this.awaitingHandlers[i],handler)){this.cleanHandler(this.awaitingHandlers[i]);this.awaitingHandlers.splice(i,1);}}}},{key:\"onHandlerStateChange\",value:function onHandlerStateChange(handler,newState,oldState,sendIfDisabled){var _this2=this;if(!handler.isEnabled()&&!sendIfDisabled){return;}this.handlingChangeSemaphore+=1;if(this.isFinished(newState)){this.awaitingHandlers.forEach(function(otherHandler){if(_this2.shouldHandlerWaitForOther(otherHandler,handler)){if(newState===State.END){otherHandler===null||otherHandler===void 0?void 0:otherHandler.cancel();if(otherHandler.getState()===State.END){otherHandler.sendEvent(State.CANCELLED,State.BEGAN);}otherHandler===null||otherHandler===void 0?void 0:otherHandler.setAwaiting(false);}else{_this2.tryActivate(otherHandler);}}});}if(newState===State.ACTIVE){this.tryActivate(handler);}else if(oldState===State.ACTIVE||oldState===State.END){if(handler.isActive()){handler.sendEvent(newState,oldState);}else if(oldState===State.ACTIVE&&(newState===State.CANCELLED||newState===State.FAILED)){handler.sendEvent(newState,State.BEGAN);}}else if(oldState!==State.UNDETERMINED||newState!==State.CANCELLED){handler.sendEvent(newState,oldState);}this.handlingChangeSemaphore-=1;this.scheduleFinishedHandlersCleanup();if(this.awaitingHandlers.indexOf(handler)<0){this.cleanupAwaitingHandlers(handler);}}},{key:\"makeActive\",value:function makeActive(handler){var _this3=this;var currentState=handler.getState();handler.setActive(true);handler.setShouldResetProgress(true);handler.setActivationIndex(this.activationIndex++);for(var i=this.gestureHandlers.length-1;i>=0;--i){if(this.shouldHandlerBeCancelledBy(this.gestureHandlers[i],handler)){this.gestureHandlers[i].cancel();}}this.awaitingHandlers.forEach(function(otherHandler){if(_this3.shouldHandlerBeCancelledBy(otherHandler,handler)){otherHandler===null||otherHandler===void 0?void 0:otherHandler.cancel();otherHandler===null||otherHandler===void 0?void 0:otherHandler.setAwaiting(true);}});handler.sendEvent(State.ACTIVE,State.BEGAN);if(currentState!==State.ACTIVE){handler.sendEvent(State.END,State.ACTIVE);if(currentState!==State.END){handler.sendEvent(State.UNDETERMINED,State.END);}}if(handler.isAwaiting()){handler.setAwaiting(false);for(var _i=0;_i<this.awaitingHandlers.length;++_i){if(this.awaitingHandlers[_i]===handler){this.awaitingHandlers.splice(_i,1);}}}}},{key:\"addAwaitingHandler\",value:function addAwaitingHandler(handler){var alreadyExists=false;this.awaitingHandlers.forEach(function(otherHandler){if(otherHandler===handler){alreadyExists=true;return;}});if(alreadyExists){return;}this.awaitingHandlers.push(handler);handler.setAwaiting(true);handler.setActivationIndex(this.activationIndex++);}},{key:\"recordHandlerIfNotPresent\",value:function recordHandlerIfNotPresent(handler){var alreadyExists=false;this.gestureHandlers.forEach(function(otherHandler){if(otherHandler===handler){alreadyExists=true;return;}});if(alreadyExists){return;}this.gestureHandlers.push(handler);handler.setActive(false);handler.setAwaiting(false);handler.setActivationIndex(Number.MAX_SAFE_INTEGER);}},{key:\"shouldHandlerWaitForOther\",value:function shouldHandlerWaitForOther(handler,otherHandler){return handler!==otherHandler&&(handler.shouldWaitForHandlerFailure(otherHandler)||otherHandler.shouldRequireToWaitForFailure(handler));}},{key:\"canRunSimultaneously\",value:function canRunSimultaneously(gh1,gh2){return gh1===gh2||gh1.shouldRecognizeSimultaneously(gh2)||gh2.shouldRecognizeSimultaneously(gh1);}},{key:\"shouldHandlerBeCancelledBy\",value:function shouldHandlerBeCancelledBy(handler,otherHandler){if(this.canRunSimultaneously(handler,otherHandler)){return false;}if(handler!==otherHandler&&(handler.isAwaiting()||handler.getState()===State.ACTIVE)){return handler.shouldBeCancelledByOther(otherHandler);}var handlerPointers=handler.getTrackedPointersID();var otherPointers=otherHandler.getTrackedPointersID();if(!PointerTracker.shareCommonPointers(handlerPointers,otherPointers)&&handler.getDelegate().getView()!==otherHandler.getDelegate().getView()){return this.checkOverlap(handler,otherHandler);}return true;}},{key:\"checkOverlap\",value:function checkOverlap(handler,otherHandler){var handlerPointers=handler.getTrackedPointersID();var otherPointers=otherHandler.getTrackedPointersID();var overlap=false;handlerPointers.forEach(function(pointer){var handlerX=handler.getTracker().getLastX(pointer);var handlerY=handler.getTracker().getLastY(pointer);if(handler.getDelegate().isPointerInBounds({x:handlerX,y:handlerY})&&otherHandler.getDelegate().isPointerInBounds({x:handlerX,y:handlerY})){overlap=true;}});otherPointers.forEach(function(pointer){var otherX=otherHandler.getTracker().getLastX(pointer);var otherY=otherHandler.getTracker().getLastY(pointer);if(handler.getDelegate().isPointerInBounds({x:otherX,y:otherY})&&otherHandler.getDelegate().isPointerInBounds({x:otherX,y:otherY})){overlap=true;}});return overlap;}},{key:\"isFinished\",value:function isFinished(state){return state===State.END||state===State.FAILED||state===State.CANCELLED;}},{key:\"cancelMouseAndPenGestures\",value:function cancelMouseAndPenGestures(currentHandler){this.gestureHandlers.forEach(function(handler){if(handler.getPointerType()!==PointerType.MOUSE&&handler.getPointerType()!==PointerType.PEN){return;}if(handler!==currentHandler){handler.cancel();}else{handler.getTracker().resetTracker();}});}}],[{key:\"getInstance\",value:function getInstance(){if(!GestureHandlerOrchestrator.instance){GestureHandlerOrchestrator.instance=new GestureHandlerOrchestrator();}return GestureHandlerOrchestrator.instance;}}]);return GestureHandlerOrchestrator;}();export{GestureHandlerOrchestrator as default};_defineProperty(GestureHandlerOrchestrator,\"instance\",void 0);","map":{"version":3,"sources":["GestureHandlerOrchestrator.ts"],"names":["State","PointerType","PointerTracker","GestureHandlerOrchestrator","constructor","scheduleFinishedHandlersCleanup","handlingChangeSemaphore","cleanupFinishedHandlers","cleanHandler","handler","reset","setActive","setAwaiting","setActivationIndex","Number","MAX_VALUE","removeHandlerFromOrchestrator","gestureHandlers","splice","indexOf","awaitingHandlers","i","length","isFinished","getState","isAwaiting","hasOtherHandlerToWaitFor","hasToWait","forEach","otherHandler","shouldHandlerWaitForOther","tryActivate","addAwaitingHandler","CANCELLED","FAILED","shouldActivate","makeActive","ACTIVE","fail","BEGAN","cancel","shouldHandlerBeCancelledBy","cleanupAwaitingHandlers","onHandlerStateChange","newState","oldState","sendIfDisabled","isEnabled","END","sendEvent","isActive","UNDETERMINED","currentState","setShouldResetProgress","activationIndex","alreadyExists","push","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","shouldBeCancelledByOther","handlerPointers","getTrackedPointersID","otherPointers","shareCommonPointers","getDelegate","getView","checkOverlap","overlap","pointer","handlerX","getTracker","getLastX","handlerY","getLastY","isPointerInBounds","x","y","otherX","otherY","state","cancelMouseAndPenGestures","currentHandler","getPointerType","MOUSE","PEN","resetTracker","getInstance","instance"],"mappings":"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","sourcesContent":["import { State } from '../../State';\nimport { PointerType } from '../interfaces';\n\nimport GestureHandler from '../handlers/GestureHandler';\nimport PointerTracker from './PointerTracker';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: GestureHandler[] = [];\n  private awaitingHandlers: GestureHandler[] = [];\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: GestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  public removeHandlerFromOrchestrator(handler: GestureHandler): void {\n    this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n    this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n  }\n\n  private cleanupFinishedHandlers(): void {\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (!handler) {\n        continue;\n      }\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.gestureHandlers.splice(i, 1);\n\n        this.cleanHandler(handler);\n      }\n    }\n  }\n\n  private hasOtherHandlerToWaitFor(handler: GestureHandler): boolean {\n    let hasToWait = false;\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (\n        otherHandler &&\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      ) {\n        hasToWait = true;\n        return;\n      }\n    });\n\n    return hasToWait;\n  }\n\n  private tryActivate(handler: GestureHandler): void {\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n    } else if (\n      handler.getState() !== State.CANCELLED &&\n      handler.getState() !== State.FAILED\n    ) {\n      if (this.shouldActivate(handler)) {\n        this.makeActive(handler);\n      } else {\n        switch (handler.getState()) {\n          case State.ACTIVE:\n            handler.fail();\n            break;\n          case State.BEGAN:\n            handler.cancel();\n        }\n      }\n    }\n  }\n\n  private shouldActivate(handler: GestureHandler): boolean {\n    for (const otherHandler of this.gestureHandlers) {\n      if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private cleanupAwaitingHandlers(handler: GestureHandler): void {\n    for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n      if (\n        !this.awaitingHandlers[i].isAwaiting() &&\n        this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)\n      ) {\n        this.cleanHandler(this.awaitingHandlers[i]);\n        this.awaitingHandlers.splice(i, 1);\n      }\n    }\n  }\n\n  public onHandlerStateChange(\n    handler: GestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      this.awaitingHandlers.forEach((otherHandler) => {\n        if (this.shouldHandlerWaitForOther(otherHandler, handler)) {\n          if (newState === State.END) {\n            otherHandler?.cancel();\n            if (otherHandler.getState() === State.END) {\n              // Handle edge case, where discrete gestures end immediately after activation thus\n              // their state is set to END and when the gesture they are waiting for activates they\n              // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n              // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n              otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n            }\n            otherHandler?.setAwaiting(false);\n          } else {\n            this.tryActivate(otherHandler);\n          }\n        }\n      });\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (this.awaitingHandlers.indexOf(handler) < 0) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: GestureHandler): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n        this.gestureHandlers[i].cancel();\n      }\n    }\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler?.cancel();\n        otherHandler?.setAwaiting(true);\n      }\n    });\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (handler.isAwaiting()) {\n      handler.setAwaiting(false);\n      for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (this.awaitingHandlers[i] === handler) {\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n  }\n\n  private addAwaitingHandler(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: GestureHandler,\n    gh2: GestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (\n      handler !== otherHandler &&\n      (handler.isAwaiting() || handler.getState() === State.ACTIVE)\n    ) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getDelegate().getView() !== otherHandler.getDelegate().getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    let overlap = false;\n\n    handlerPointers.forEach((pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      if (\n        handler.getDelegate().isPointerInBounds({ x: handlerX, y: handlerY }) &&\n        otherHandler\n          .getDelegate()\n          .isPointerInBounds({ x: handlerX, y: handlerY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    otherPointers.forEach((pointer: number) => {\n      const otherX: number = otherHandler.getTracker().getLastX(pointer);\n      const otherY: number = otherHandler.getTracker().getLastY(pointer);\n\n      if (\n        handler.getDelegate().isPointerInBounds({ x: otherX, y: otherY }) &&\n        otherHandler.getDelegate().isPointerInBounds({ x: otherX, y: otherY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    return overlap;\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: GestureHandler): void {\n    this.gestureHandlers.forEach((handler: GestureHandler) => {\n      if (\n        handler.getPointerType() !== PointerType.MOUSE &&\n        handler.getPointerType() !== PointerType.PEN\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}