{"ast":null,"code":"'use strict';import{isJest}from'./PlatformChecker';import{runOnUI}from'./threads';import{isSharedValue}from'./isSharedValue';var IS_JEST=isJest();var _worklet_5405073416202_init_data={code:\"function createMapperRegistry(){const{IS_JEST,isSharedValue}=this.__closure;const mappers=new Map();let sortedMappers=[];let runRequested=false;let processingMappers=false;function updateMappersOrder(){const pre=new Map();mappers.forEach(function(mapper){if(mapper.outputs){for(const output of mapper.outputs){const preMappers=pre.get(output);if(preMappers===undefined){pre.set(output,[mapper]);}else{preMappers.push(mapper);}}}});const visited=new Set();const newOrder=[];function dfs(mapper){visited.add(mapper);for(const input of mapper.inputs){const preMappers=pre.get(input);if(preMappers){for(const preMapper of preMappers){if(!visited.has(preMapper)){dfs(preMapper);}}}}newOrder.push(mapper);}mappers.forEach(function(mapper){if(!visited.has(mapper)){dfs(mapper);}});sortedMappers=newOrder;}function mapperRun(){runRequested=false;if(processingMappers){return;}try{processingMappers=true;if(mappers.size!==sortedMappers.length){updateMappersOrder();}for(const mapper of sortedMappers){if(mapper.dirty){mapper.dirty=false;mapper.worklet();}}}finally{processingMappers=false;}}function maybeRequestUpdates(){if(IS_JEST){mapperRun();}else if(!runRequested){if(processingMappers){requestAnimationFrame(mapperRun);}else{queueMicrotask(mapperRun);}runRequested=true;}}function extractInputs(inputs,resultArray){if(Array.isArray(inputs)){for(const input of inputs){input&&extractInputs(input,resultArray);}}else if(isSharedValue(inputs)){resultArray.push(inputs);}else if(Object.getPrototypeOf(inputs)===Object.prototype){for(const element of Object.values(inputs)){element&&extractInputs(element,resultArray);}}return resultArray;}return{start:function(mapperID,worklet,inputs,outputs){const mapper={id:mapperID,dirty:true,worklet:worklet,inputs:extractInputs(inputs,[]),outputs:outputs};mappers.set(mapper.id,mapper);sortedMappers=[];for(const sv of mapper.inputs){sv.addListener(mapper.id,function(){mapper.dirty=true;maybeRequestUpdates();});}maybeRequestUpdates();},stop:function(mapperID){const mapper=mappers.get(mapperID);if(mapper){mappers.delete(mapper.id);sortedMappers=[];for(const sv of mapper.inputs){sv.removeListener(mapper.id);}}}};}\"};var createMapperRegistry=function(){var createMapperRegistry=function createMapperRegistry(){var mappers=new Map();var sortedMappers=[];var runRequested=false;var processingMappers=false;function updateMappersOrder(){var pre=new Map();mappers.forEach(function(mapper){if(mapper.outputs){for(var output of mapper.outputs){var preMappers=pre.get(output);if(preMappers===undefined){pre.set(output,[mapper]);}else{preMappers.push(mapper);}}}});var visited=new Set();var newOrder=[];function dfs(mapper){visited.add(mapper);for(var input of mapper.inputs){var preMappers=pre.get(input);if(preMappers){for(var preMapper of preMappers){if(!visited.has(preMapper)){dfs(preMapper);}}}}newOrder.push(mapper);}mappers.forEach(function(mapper){if(!visited.has(mapper)){dfs(mapper);}});sortedMappers=newOrder;}function mapperRun(){runRequested=false;if(processingMappers){return;}try{processingMappers=true;if(mappers.size!==sortedMappers.length){updateMappersOrder();}for(var mapper of sortedMappers){if(mapper.dirty){mapper.dirty=false;mapper.worklet();}}}finally{processingMappers=false;}}function maybeRequestUpdates(){if(IS_JEST){mapperRun();}else if(!runRequested){if(processingMappers){requestAnimationFrame(mapperRun);}else{queueMicrotask(mapperRun);}runRequested=true;}}function extractInputs(inputs,resultArray){if(Array.isArray(inputs)){for(var input of inputs){input&&extractInputs(input,resultArray);}}else if(isSharedValue(inputs)){resultArray.push(inputs);}else if(Object.getPrototypeOf(inputs)===Object.prototype){for(var element of Object.values(inputs)){element&&extractInputs(element,resultArray);}}return resultArray;}return{start:function start(mapperID,worklet,inputs,outputs){var mapper={id:mapperID,dirty:true,worklet:worklet,inputs:extractInputs(inputs,[]),outputs:outputs};mappers.set(mapper.id,mapper);sortedMappers=[];for(var sv of mapper.inputs){sv.addListener(mapper.id,function(){mapper.dirty=true;maybeRequestUpdates();});}maybeRequestUpdates();},stop:function stop(mapperID){var mapper=mappers.get(mapperID);if(mapper){mappers.delete(mapper.id);sortedMappers=[];for(var sv of mapper.inputs){sv.removeListener(mapper.id);}}}};};createMapperRegistry.__closure={IS_JEST:IS_JEST,isSharedValue:isSharedValue};createMapperRegistry.__workletHash=5405073416202;createMapperRegistry.__initData=_worklet_5405073416202_init_data;return createMapperRegistry;}();var MAPPER_ID=9999;var _worklet_16857838132571_init_data={code:\"function anonymous(){const{createMapperRegistry,mapperID,worklet,inputs,outputs}=this.__closure;let mapperRegistry=global.__mapperRegistry;if(mapperRegistry===undefined){mapperRegistry=global.__mapperRegistry=createMapperRegistry();}mapperRegistry.start(mapperID,worklet,inputs,outputs);}\"};export function startMapper(worklet){var inputs=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var outputs=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];var mapperID=MAPPER_ID+=1;runOnUI(function(){var anonymous=function anonymous(){var mapperRegistry=global.__mapperRegistry;if(mapperRegistry===undefined){mapperRegistry=global.__mapperRegistry=createMapperRegistry();}mapperRegistry.start(mapperID,worklet,inputs,outputs);};anonymous.__closure={createMapperRegistry:createMapperRegistry,mapperID:mapperID,worklet:worklet,inputs:inputs,outputs:outputs};anonymous.__workletHash=16857838132571;anonymous.__initData=_worklet_16857838132571_init_data;return anonymous;}())();return mapperID;}var _worklet_9518448685143_init_data={code:\"function anonymous(){const{mapperID}=this.__closure;const mapperRegistry=global.__mapperRegistry;mapperRegistry===null||mapperRegistry===void 0?void 0:mapperRegistry.stop(mapperID);}\"};export function stopMapper(mapperID){runOnUI(function(){var anonymous=function anonymous(){var mapperRegistry=global.__mapperRegistry;mapperRegistry===null||mapperRegistry===void 0?void 0:mapperRegistry.stop(mapperID);};anonymous.__closure={mapperID:mapperID};anonymous.__workletHash=9518448685143;anonymous.__initData=_worklet_9518448685143_init_data;return anonymous;}())();}","map":{"version":3,"sources":["mappers.ts"],"names":["isJest","runOnUI","isSharedValue","IS_JEST","createMapperRegistry","mappers","Map","sortedMappers","runRequested","processingMappers","updateMappersOrder","pre","forEach","mapper","outputs","output","preMappers","get","undefined","set","push","visited","Set","newOrder","dfs","add","input","inputs","preMapper","has","mapperRun","size","length","dirty","worklet","maybeRequestUpdates","requestAnimationFrame","queueMicrotask","extractInputs","resultArray","Array","isArray","Object","getPrototypeOf","prototype","element","values","start","mapperID","id","sv","addListener","stop","delete","removeListener","MAPPER_ID","startMapper","mapperRegistry","global","__mapperRegistry","stopMapper"],"mappings":"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","sourcesContent":["'use strict';\nimport type { SharedValue } from './commonTypes';\nimport { isJest } from './PlatformChecker';\nimport { runOnUI } from './threads';\nimport { isSharedValue } from './isSharedValue';\n\nconst IS_JEST = isJest();\n\ntype Mapper = {\n  id: number;\n  dirty: boolean;\n  worklet: () => void;\n  inputs: SharedValue<any>[];\n  outputs?: SharedValue<any>[];\n};\n\nfunction createMapperRegistry() {\n  'worklet';\n  const mappers = new Map();\n  let sortedMappers: Mapper[] = [];\n\n  let runRequested = false;\n  let processingMappers = false;\n\n  function updateMappersOrder() {\n    // sort mappers topologically\n    // the algorithm here takes adventage of a fact that the topological order\n    // of a transposed graph is a reverse topological order of the original graph\n    // The graph in our case consists of mappers and an edge between two mappers\n    // A and B exists if there is a shared value that's on A's output lists and on\n    // B's input list.\n    //\n    // We don't need however to calculate that graph as it is easier to work with\n    // the transposed version of it that can be calculated ad-hoc. For the transposed\n    // version to be traversed we use \"pre\" map that maps share value to mappers that\n    // output that shared value. Then we can infer all the outgoing edges for a given\n    // mapper simply by scanning it's input list and checking if any of the shared values\n    // from that list exists in the \"pre\" map. If they do, then we have an edge between\n    // that mapper and the mappers from the \"pre\" list for the given shared value.\n    //\n    // For topological sorting we use a dfs-based approach that requires the graph to\n    // be traversed in dfs order and each node after being processed lands at the\n    // beginning of the topological order list. Since we traverse a transposed graph,\n    // instead of reversing that order we can use a normal array and push processed\n    // mappers to the end. There is no need to reverse that array after we are done.\n    const pre = new Map(); // map from sv -> mapper that outputs that sv\n    mappers.forEach((mapper) => {\n      if (mapper.outputs) {\n        for (const output of mapper.outputs) {\n          const preMappers = pre.get(output);\n          if (preMappers === undefined) {\n            pre.set(output, [mapper]);\n          } else {\n            preMappers.push(mapper);\n          }\n        }\n      }\n    });\n    const visited = new Set();\n    const newOrder: Mapper[] = [];\n    function dfs(mapper: Mapper) {\n      visited.add(mapper);\n      for (const input of mapper.inputs) {\n        const preMappers = pre.get(input);\n        if (preMappers) {\n          for (const preMapper of preMappers) {\n            if (!visited.has(preMapper)) {\n              dfs(preMapper);\n            }\n          }\n        }\n      }\n      newOrder.push(mapper);\n    }\n    mappers.forEach((mapper) => {\n      if (!visited.has(mapper)) {\n        dfs(mapper);\n      }\n    });\n    sortedMappers = newOrder;\n  }\n\n  function mapperRun() {\n    runRequested = false;\n    if (processingMappers) {\n      return;\n    }\n    try {\n      processingMappers = true;\n      if (mappers.size !== sortedMappers.length) {\n        updateMappersOrder();\n      }\n      for (const mapper of sortedMappers) {\n        if (mapper.dirty) {\n          mapper.dirty = false;\n          mapper.worklet();\n        }\n      }\n    } finally {\n      processingMappers = false;\n    }\n  }\n\n  function maybeRequestUpdates() {\n    if (IS_JEST) {\n      // On Jest environment we avoid using queueMicrotask as that'd require test\n      // to advance the clock manually. This on other hand would require tests\n      // to know how many times mappers need to run. As we don't want tests to\n      // make any assumptions on that number it is easier to execute mappers\n      // immediately for testing purposes and only expect test to advance timers\n      // if they want to make any assertions on the effects of animations being run.\n      mapperRun();\n    } else if (!runRequested) {\n      if (processingMappers) {\n        // In general, we should avoid having mappers trigger updates as this may\n        // result in unpredictable behavior. Specifically, the updated value can\n        // be read by mappers that run later in the same frame but previous mappers\n        // would access the old value. Updating mappers during the mapper-run phase\n        // breaks the order in which we should execute the mappers. However, doing\n        // that is still a possibility and there are some instances where people use\n        // the API in that way, hence we need to prevent mapper-run phase falling into\n        // an infinite loop. We do that by detecting when mapper-run is requested while\n        // we are already in mapper-run phase, and in that case we use `requestAnimationFrame`\n        // instead of `queueMicrotask` which will schedule mapper run for the next\n        // frame instead of queuing another set of updates in the same frame.\n        requestAnimationFrame(mapperRun);\n      } else {\n        queueMicrotask(mapperRun);\n      }\n      runRequested = true;\n    }\n  }\n\n  function extractInputs(\n    inputs: any,\n    resultArray: SharedValue<any>[]\n  ): SharedValue<any>[] {\n    if (Array.isArray(inputs)) {\n      for (const input of inputs) {\n        input && extractInputs(input, resultArray);\n      }\n    } else if (isSharedValue(inputs)) {\n      resultArray.push(inputs);\n    } else if (Object.getPrototypeOf(inputs) === Object.prototype) {\n      // we only extract inputs recursively from \"plain\" objects here, if object\n      // is of a derivative class (e.g. HostObject on web, or Map) we don't scan\n      // it recursively\n      for (const element of Object.values(inputs)) {\n        element && extractInputs(element, resultArray);\n      }\n    }\n    return resultArray;\n  }\n\n  return {\n    start: (\n      mapperID: number,\n      worklet: () => void,\n      inputs: SharedValue<any>[],\n      outputs?: SharedValue<any>[]\n    ) => {\n      const mapper = {\n        id: mapperID,\n        dirty: true,\n        worklet,\n        inputs: extractInputs(inputs, []),\n        outputs,\n      };\n      mappers.set(mapper.id, mapper);\n      sortedMappers = [];\n      for (const sv of mapper.inputs) {\n        sv.addListener(mapper.id, () => {\n          mapper.dirty = true;\n          maybeRequestUpdates();\n        });\n      }\n      maybeRequestUpdates();\n    },\n    stop: (mapperID: number) => {\n      const mapper = mappers.get(mapperID);\n      if (mapper) {\n        mappers.delete(mapper.id);\n        sortedMappers = [];\n        for (const sv of mapper.inputs) {\n          sv.removeListener(mapper.id);\n        }\n      }\n    },\n  };\n}\n\nlet MAPPER_ID = 9999;\n\nexport function startMapper(\n  worklet: () => void,\n  inputs: any[] = [],\n  outputs: any[] = []\n): number {\n  const mapperID = (MAPPER_ID += 1);\n\n  runOnUI(() => {\n    let mapperRegistry = global.__mapperRegistry;\n    if (mapperRegistry === undefined) {\n      mapperRegistry = global.__mapperRegistry = createMapperRegistry();\n    }\n    mapperRegistry.start(mapperID, worklet, inputs, outputs);\n  })();\n\n  return mapperID;\n}\n\nexport function stopMapper(mapperID: number): void {\n  runOnUI(() => {\n    const mapperRegistry = global.__mapperRegistry;\n    mapperRegistry?.stop(mapperID);\n  })();\n}\n"]},"metadata":{},"sourceType":"module"}