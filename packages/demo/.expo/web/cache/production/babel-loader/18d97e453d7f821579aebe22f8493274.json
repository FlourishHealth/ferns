{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}var EventManager=function(){function EventManager(view){_classCallCheck(this,EventManager);_defineProperty(this,\"view\",void 0);_defineProperty(this,\"pointersInBounds\",[]);_defineProperty(this,\"activePointersCounter\",void 0);this.view=view;this.activePointersCounter=0;}_createClass(EventManager,[{key:\"onPointerDown\",value:function onPointerDown(_event){}},{key:\"onPointerAdd\",value:function onPointerAdd(_event){}},{key:\"onPointerUp\",value:function onPointerUp(_event){}},{key:\"onPointerRemove\",value:function onPointerRemove(_event){}},{key:\"onPointerMove\",value:function onPointerMove(_event){}},{key:\"onPointerLeave\",value:function onPointerLeave(_event){}},{key:\"onPointerEnter\",value:function onPointerEnter(_event){}},{key:\"onPointerCancel\",value:function onPointerCancel(_event){}},{key:\"onPointerOutOfBounds\",value:function onPointerOutOfBounds(_event){}},{key:\"onPointerMoveOver\",value:function onPointerMoveOver(_event){}},{key:\"onPointerMoveOut\",value:function onPointerMoveOut(_event){}},{key:\"setOnPointerDown\",value:function setOnPointerDown(callback){this.onPointerDown=callback;}},{key:\"setOnPointerAdd\",value:function setOnPointerAdd(callback){this.onPointerAdd=callback;}},{key:\"setOnPointerUp\",value:function setOnPointerUp(callback){this.onPointerUp=callback;}},{key:\"setOnPointerRemove\",value:function setOnPointerRemove(callback){this.onPointerRemove=callback;}},{key:\"setOnPointerMove\",value:function setOnPointerMove(callback){this.onPointerMove=callback;}},{key:\"setOnPointerLeave\",value:function setOnPointerLeave(callback){this.onPointerLeave=callback;}},{key:\"setOnPointerEnter\",value:function setOnPointerEnter(callback){this.onPointerEnter=callback;}},{key:\"setOnPointerCancel\",value:function setOnPointerCancel(callback){this.onPointerCancel=callback;}},{key:\"setOnPointerOutOfBounds\",value:function setOnPointerOutOfBounds(callback){this.onPointerOutOfBounds=callback;}},{key:\"setOnPointerMoveOver\",value:function setOnPointerMoveOver(callback){this.onPointerMoveOver=callback;}},{key:\"setOnPointerMoveOut\",value:function setOnPointerMoveOut(callback){this.onPointerMoveOut=callback;}},{key:\"markAsInBounds\",value:function markAsInBounds(pointerId){if(this.pointersInBounds.indexOf(pointerId)>=0){return;}this.pointersInBounds.push(pointerId);}},{key:\"markAsOutOfBounds\",value:function markAsOutOfBounds(pointerId){var index=this.pointersInBounds.indexOf(pointerId);if(index<0){return;}this.pointersInBounds.splice(index,1);}},{key:\"resetManager\",value:function resetManager(){this.activePointersCounter=0;this.pointersInBounds=[];}}]);return EventManager;}();export{EventManager as default};","map":{"version":3,"sources":["EventManager.ts"],"names":["EventManager","constructor","view","activePointersCounter","onPointerDown","_event","onPointerAdd","onPointerUp","onPointerRemove","onPointerMove","onPointerLeave","onPointerEnter","onPointerCancel","onPointerOutOfBounds","onPointerMoveOver","onPointerMoveOut","setOnPointerDown","callback","setOnPointerAdd","setOnPointerUp","setOnPointerRemove","setOnPointerMove","setOnPointerLeave","setOnPointerEnter","setOnPointerCancel","setOnPointerOutOfBounds","setOnPointerMoveOver","setOnPointerMoveOut","markAsInBounds","pointerId","pointersInBounds","indexOf","push","markAsOutOfBounds","index","splice","resetManager"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\nimport { AdaptedEvent, EventTypes, TouchEventType } from '../interfaces';\n\nexport default abstract class EventManager<T> {\n  protected readonly view: T;\n  protected pointersInBounds: number[] = [];\n  protected activePointersCounter: number;\n\n  constructor(view: T) {\n    this.view = view;\n    this.activePointersCounter = 0;\n  }\n\n  public abstract setListeners(): void;\n  protected abstract mapEvent(\n    event: Event,\n    eventType: EventTypes,\n    index?: number,\n    touchEventType?: TouchEventType\n  ): AdaptedEvent;\n\n  protected onPointerDown(_event: AdaptedEvent): void {}\n  protected onPointerAdd(_event: AdaptedEvent): void {}\n  protected onPointerUp(_event: AdaptedEvent): void {}\n  protected onPointerRemove(_event: AdaptedEvent): void {}\n  protected onPointerMove(_event: AdaptedEvent): void {}\n  protected onPointerLeave(_event: AdaptedEvent): void {} // called only when pointer is pressed (or touching)\n  protected onPointerEnter(_event: AdaptedEvent): void {} // called only when pointer is pressed (or touching)\n  protected onPointerCancel(_event: AdaptedEvent): void {\n    // When pointer cancel is triggered and there are more pointers on the view, only one pointer is cancelled\n    // Because we want all pointers to be cancelled by that event, we are doing it manually by reseting handler and changing activePointersCounter to 0\n    // Events that correspond to removing the pointer (pointerup, touchend) have condition, that they don't perform any action when activePointersCounter\n    // is equal to 0. This prevents counter from going to negative values, when pointers are removed from view after one of them has been cancelled\n  }\n  protected onPointerOutOfBounds(_event: AdaptedEvent): void {}\n  protected onPointerMoveOver(_event: AdaptedEvent): void {}\n  protected onPointerMoveOut(_event: AdaptedEvent): void {}\n\n  public setOnPointerDown(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerDown = callback;\n  }\n  public setOnPointerAdd(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerAdd = callback;\n  }\n  public setOnPointerUp(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerUp = callback;\n  }\n  public setOnPointerRemove(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerRemove = callback;\n  }\n  public setOnPointerMove(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerMove = callback;\n  }\n  public setOnPointerLeave(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerLeave = callback;\n  }\n  public setOnPointerEnter(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerEnter = callback;\n  }\n  public setOnPointerCancel(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerCancel = callback;\n  }\n  public setOnPointerOutOfBounds(\n    callback: (event: AdaptedEvent) => void\n  ): void {\n    this.onPointerOutOfBounds = callback;\n  }\n  public setOnPointerMoveOver(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerMoveOver = callback;\n  }\n  public setOnPointerMoveOut(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerMoveOut = callback;\n  }\n\n  protected markAsInBounds(pointerId: number): void {\n    if (this.pointersInBounds.indexOf(pointerId) >= 0) {\n      return;\n    }\n\n    this.pointersInBounds.push(pointerId);\n  }\n\n  protected markAsOutOfBounds(pointerId: number): void {\n    const index: number = this.pointersInBounds.indexOf(pointerId);\n\n    if (index < 0) {\n      return;\n    }\n\n    this.pointersInBounds.splice(index, 1);\n  }\n\n  public resetManager(): void {\n    // Reseting activePointersCounter is necessary to make gestures such as pinch work properly\n    // There are gestures that end when there is still one active pointer (like pinch/rotation)\n    // When these gestures end, they are reset, but they still receive events from pointer that is active\n    // This causes trouble, since only onPointerDown registers gesture in orchestrator, and while gestures receive\n    // Events from active pointer after they finished, next pointerdown event will be registered as additional pointer, not the first one\n    // This casues trouble like gestures getting stuck in END state, even though they should have gone to UNDETERMINED\n\n    this.activePointersCounter = 0;\n    this.pointersInBounds = [];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}