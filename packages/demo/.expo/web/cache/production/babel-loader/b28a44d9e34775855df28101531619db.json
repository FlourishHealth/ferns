{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import CircularBuffer from'./CircularBuffer';import LeastSquareSolver from'./LeastSquareSolver';var VelocityTracker=function(){function VelocityTracker(){_classCallCheck(this,VelocityTracker);_defineProperty(this,\"assumePointerMoveStoppedMilliseconds\",40);_defineProperty(this,\"historySize\",20);_defineProperty(this,\"horizonMilliseconds\",300);_defineProperty(this,\"minSampleSize\",3);_defineProperty(this,\"samples\",void 0);this.samples=new CircularBuffer(this.historySize);}_createClass(VelocityTracker,[{key:\"add\",value:function add(event){this.samples.push(event);}},{key:\"getVelocityEstimate\",value:function getVelocityEstimate(){var x=[];var y=[];var w=[];var time=[];var sampleCount=0;var index=this.samples.size-1;var newestSample=this.samples.get(index);if(!newestSample){return null;}var previousSample=newestSample;while(sampleCount<this.samples.size){var sample=this.samples.get(index);var age=newestSample.time-sample.time;var delta=Math.abs(sample.time-previousSample.time);previousSample=sample;if(age>this.horizonMilliseconds||delta>this.assumePointerMoveStoppedMilliseconds){break;}x.push(sample.x);y.push(sample.y);w.push(1);time.push(-age);sampleCount++;index--;}if(sampleCount>=this.minSampleSize){var xSolver=new LeastSquareSolver(time,x,w);var xFit=xSolver.solve(2);if(xFit!==null){var ySolver=new LeastSquareSolver(time,y,w);var yFit=ySolver.solve(2);if(yFit!==null){var xVelocity=xFit.coefficients[1]*1000;var yVelocity=yFit.coefficients[1]*1000;return[xVelocity,yVelocity];}}}return null;}},{key:\"getVelocity\",value:function getVelocity(){var estimate=this.getVelocityEstimate();if(estimate!==null){return estimate;}return[0,0];}},{key:\"reset\",value:function reset(){this.samples.clear();}}]);return VelocityTracker;}();export{VelocityTracker as default};","map":{"version":3,"sources":["VelocityTracker.ts"],"names":["CircularBuffer","LeastSquareSolver","VelocityTracker","constructor","samples","historySize","add","event","push","getVelocityEstimate","x","y","w","time","sampleCount","index","size","newestSample","get","previousSample","sample","age","delta","Math","abs","horizonMilliseconds","assumePointerMoveStoppedMilliseconds","minSampleSize","xSolver","xFit","solve","ySolver","yFit","xVelocity","coefficients","yVelocity","getVelocity","estimate","reset","clear"],"mappings":"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","sourcesContent":["import { AdaptedEvent } from '../interfaces';\nimport CircularBuffer from './CircularBuffer';\nimport LeastSquareSolver from './LeastSquareSolver';\n\nexport default class VelocityTracker {\n  private assumePointerMoveStoppedMilliseconds = 40;\n  private historySize = 20;\n  private horizonMilliseconds = 300;\n  private minSampleSize = 3;\n\n  private samples: CircularBuffer<AdaptedEvent>;\n\n  constructor() {\n    this.samples = new CircularBuffer<AdaptedEvent>(this.historySize);\n  }\n\n  public add(event: AdaptedEvent): void {\n    this.samples.push(event);\n  }\n\n  /// Returns an estimate of the velocity of the object being tracked by the\n  /// tracker given the current information available to the tracker.\n  ///\n  /// Information is added using [addPosition].\n  ///\n  /// Returns null if there is no data on which to base an estimate.\n  private getVelocityEstimate(): [number, number] | null {\n    const x = [];\n    const y = [];\n    const w = [];\n    const time = [];\n\n    let sampleCount = 0;\n    let index = this.samples.size - 1;\n    const newestSample = this.samples.get(index);\n    if (!newestSample) {\n      return null;\n    }\n\n    let previousSample = newestSample;\n\n    // Starting with the most recent PointAtTime sample, iterate backwards while\n    // the samples represent continuous motion.\n    while (sampleCount < this.samples.size) {\n      const sample = this.samples.get(index);\n\n      const age = newestSample.time - sample.time;\n      const delta = Math.abs(sample.time - previousSample.time);\n      previousSample = sample;\n\n      if (\n        age > this.horizonMilliseconds ||\n        delta > this.assumePointerMoveStoppedMilliseconds\n      ) {\n        break;\n      }\n\n      x.push(sample.x);\n      y.push(sample.y);\n      w.push(1);\n      time.push(-age);\n\n      sampleCount++;\n      index--;\n    }\n\n    if (sampleCount >= this.minSampleSize) {\n      const xSolver = new LeastSquareSolver(time, x, w);\n      const xFit = xSolver.solve(2);\n\n      if (xFit !== null) {\n        const ySolver = new LeastSquareSolver(time, y, w);\n        const yFit = ySolver.solve(2);\n\n        if (yFit !== null) {\n          const xVelocity = xFit.coefficients[1] * 1000;\n          const yVelocity = yFit.coefficients[1] * 1000;\n\n          return [xVelocity, yVelocity];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  public getVelocity(): [number, number] {\n    const estimate = this.getVelocityEstimate();\n    if (estimate !== null) {\n      return estimate;\n    }\n    return [0, 0];\n  }\n\n  public reset(): void {\n    this.samples.clear();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}