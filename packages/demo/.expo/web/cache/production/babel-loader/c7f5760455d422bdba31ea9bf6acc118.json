{"ast":null,"code":"'use strict';import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}import React,{Children,Component,createContext,useEffect,useRef}from'react';import{setShouldAnimateExitingForTag}from'../core';import findNodeHandle from\"react-native-web/dist/exports/findNodeHandle\";export var SkipEnteringContext=createContext(null);function SkipEntering(props){var skipValueRef=useRef(props.shouldSkip);useEffect(function(){skipValueRef.current=false;},[skipValueRef]);return React.createElement(SkipEnteringContext.Provider,{value:skipValueRef},props.children);}export var LayoutAnimationConfig=function(_Component){_inherits(LayoutAnimationConfig,_Component);var _super=_createSuper(LayoutAnimationConfig);function LayoutAnimationConfig(){_classCallCheck(this,LayoutAnimationConfig);return _super.apply(this,arguments);}_createClass(LayoutAnimationConfig,[{key:\"getMaybeWrappedChildren\",value:function getMaybeWrappedChildren(){return Children.count(this.props.children)>1&&this.props.skipExiting?Children.map(this.props.children,function(child){return React.createElement(LayoutAnimationConfig,{skipExiting:true},child);}):this.props.children;}},{key:\"setShouldAnimateExiting\",value:function setShouldAnimateExiting(){if(Children.count(this.props.children)===1){var tag=findNodeHandle(this);if(tag){setShouldAnimateExitingForTag(tag,!this.props.skipExiting);}}}},{key:\"componentWillUnmount\",value:function componentWillUnmount(){if(this.props.skipExiting!==undefined){this.setShouldAnimateExiting();}}},{key:\"render\",value:function render(){var children=this.getMaybeWrappedChildren();if(this.props.skipEntering===undefined){return children;}return React.createElement(SkipEntering,{shouldSkip:this.props.skipEntering},children);}}]);return LayoutAnimationConfig;}(Component);","map":{"version":3,"sources":["LayoutAnimationConfig.tsx"],"names":["React","Children","Component","createContext","useEffect","useRef","setShouldAnimateExitingForTag","SkipEnteringContext","SkipEntering","props","skipValueRef","shouldSkip","current","Provider","value","children","LayoutAnimationConfig","getMaybeWrappedChildren","count","skipExiting","map","child","setShouldAnimateExiting","tag","findNodeHandle","componentWillUnmount","undefined","render","skipEntering"],"mappings":"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","sourcesContent":["'use strict';\nimport React, {\n  Children,\n  Component,\n  createContext,\n  useEffect,\n  useRef,\n} from 'react';\nimport type { ReactNode } from 'react';\nimport { setShouldAnimateExitingForTag } from '../core';\nimport { findNodeHandle } from 'react-native';\n\nexport const SkipEnteringContext =\n  createContext<React.MutableRefObject<boolean> | null>(null);\n\n// skipEntering - don't animate entering of children on wrapper mount\n// skipExiting - don't animate exiting of children on wrapper unmount\ninterface LayoutAnimationConfigProps {\n  skipEntering?: boolean;\n  skipExiting?: boolean;\n  children: ReactNode;\n}\n\nfunction SkipEntering(props: { shouldSkip: boolean; children: ReactNode }) {\n  const skipValueRef = useRef(props.shouldSkip);\n\n  useEffect(() => {\n    skipValueRef.current = false;\n  }, [skipValueRef]);\n\n  return (\n    <SkipEnteringContext.Provider value={skipValueRef}>\n      {props.children}\n    </SkipEnteringContext.Provider>\n  );\n}\n\n// skipExiting (unlike skipEntering) cannot be done by conditionally\n// configuring the animation in `createAnimatedComponent`, since at this stage\n// we don't know if the wrapper is going to be unmounted or not.\n// That's why we need to pass the skipExiting flag to the native side\n// when the wrapper is unmounted to prevent the animation.\n// Since `ReactNode` can be a list of nodes, we wrap every child with our wrapper\n// so we are able to access its tag with `findNodeHandle`.\n/**\n * A component that lets you skip entering and exiting animations.\n *\n * @param skipEntering - A boolean indicating whether children's entering animations should be skipped when `LayoutAnimationConfig` is mounted.\n * @param skipExiting - A boolean indicating whether children's exiting animations should be skipped when LayoutAnimationConfig is unmounted.\n * @see https://docs.swmansion.com/react-native-reanimated/docs/layout-animations/layout-animation-config/\n */\nexport class LayoutAnimationConfig extends Component<LayoutAnimationConfigProps> {\n  getMaybeWrappedChildren() {\n    return Children.count(this.props.children) > 1 && this.props.skipExiting\n      ? Children.map(this.props.children, (child) => (\n          <LayoutAnimationConfig skipExiting>{child}</LayoutAnimationConfig>\n        ))\n      : this.props.children;\n  }\n\n  setShouldAnimateExiting() {\n    if (Children.count(this.props.children) === 1) {\n      const tag = findNodeHandle(this);\n      if (tag) {\n        setShouldAnimateExitingForTag(tag, !this.props.skipExiting);\n      }\n    }\n  }\n\n  componentWillUnmount(): void {\n    if (this.props.skipExiting !== undefined) {\n      this.setShouldAnimateExiting();\n    }\n  }\n\n  render(): ReactNode {\n    const children = this.getMaybeWrappedChildren();\n\n    if (this.props.skipEntering === undefined) {\n      return children;\n    }\n\n    return (\n      <SkipEntering shouldSkip={this.props.skipEntering}>\n        {children}\n      </SkipEntering>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}