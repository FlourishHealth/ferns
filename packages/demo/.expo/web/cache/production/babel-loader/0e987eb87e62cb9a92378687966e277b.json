{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}import GestureHandler from'./GestureHandler';import{TEST_MAX_IF_NOT_NAN}from'./utils';var DiscreteGestureHandler=function(_GestureHandler){_inherits(DiscreteGestureHandler,_GestureHandler);var _super=_createSuper(DiscreteGestureHandler);function DiscreteGestureHandler(){_classCallCheck(this,DiscreteGestureHandler);return _super.apply(this,arguments);}_createClass(DiscreteGestureHandler,[{key:\"isDiscrete\",get:function get(){return true;}},{key:\"shouldEnableGestureOnSetup\",get:function get(){return true;}},{key:\"shouldFailUnderCustomCriteria\",value:function shouldFailUnderCustomCriteria(_ref,_ref2){var x=_ref.x,y=_ref.y,deltaX=_ref.deltaX,deltaY=_ref.deltaY;var maxDeltaX=_ref2.maxDeltaX,maxDeltaY=_ref2.maxDeltaY,maxDistSq=_ref2.maxDistSq,shouldCancelWhenOutside=_ref2.shouldCancelWhenOutside;if(shouldCancelWhenOutside){if(!this.isPointInView({x:x,y:y})){return true;}}return TEST_MAX_IF_NOT_NAN(Math.abs(deltaX),maxDeltaX)||TEST_MAX_IF_NOT_NAN(Math.abs(deltaY),maxDeltaY)||TEST_MAX_IF_NOT_NAN(Math.abs(deltaY*deltaY+deltaX*deltaX),maxDistSq);}},{key:\"transformNativeEvent\",value:function transformNativeEvent(_ref3){var _ref3$center=_ref3.center,x=_ref3$center.x,y=_ref3$center.y;var rect=this.view.getBoundingClientRect();return{absoluteX:x,absoluteY:y,x:x-rect.left,y:y-rect.top};}},{key:\"isGestureEnabledForEvent\",value:function isGestureEnabledForEvent(_ref4,_recognizer,_ref5){var minPointers=_ref4.minPointers,maxPointers=_ref4.maxPointers,maxDeltaX=_ref4.maxDeltaX,maxDeltaY=_ref4.maxDeltaY,maxDistSq=_ref4.maxDistSq,shouldCancelWhenOutside=_ref4.shouldCancelWhenOutside;var pointerLength=_ref5.maxPointers,center=_ref5.center,deltaX=_ref5.deltaX,deltaY=_ref5.deltaY;var validPointerCount=pointerLength>=minPointers&&pointerLength<=maxPointers;if(this.shouldFailUnderCustomCriteria(_objectSpread(_objectSpread({},center),{},{deltaX:deltaX,deltaY:deltaY}),{maxDeltaX:maxDeltaX,maxDeltaY:maxDeltaY,maxDistSq:maxDistSq,shouldCancelWhenOutside:shouldCancelWhenOutside})||!validPointerCount&&this.isGestureRunning){return{failed:true};}return{success:validPointerCount};}}]);return DiscreteGestureHandler;}(GestureHandler);export default DiscreteGestureHandler;","map":{"version":3,"sources":["DiscreteGestureHandler.ts"],"names":["GestureHandler","TEST_MAX_IF_NOT_NAN","DiscreteGestureHandler","isDiscrete","shouldEnableGestureOnSetup","shouldFailUnderCustomCriteria","x","y","deltaX","deltaY","maxDeltaX","maxDeltaY","maxDistSq","shouldCancelWhenOutside","isPointInView","Math","abs","transformNativeEvent","center","rect","view","getBoundingClientRect","absoluteX","absoluteY","left","top","isGestureEnabledForEvent","minPointers","maxPointers","_recognizer","pointerLength","validPointerCount","isGestureRunning","failed","success"],"mappings":"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","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\n\nabstract class DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { x, y, deltaX, deltaY }: any,\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any\n  ) {\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({ x, y })) {\n        return true;\n      }\n    }\n    return (\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\n      TEST_MAX_IF_NOT_NAN(\n        Math.abs(deltaY * deltaY + deltaX * deltaX),\n        maxDistSq\n      )\n    );\n  }\n\n  transformNativeEvent({ center: { x, y } }: any) {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n\n  isGestureEnabledForEvent(\n    {\n      minPointers,\n      maxPointers,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside,\n    }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength, center, deltaX, deltaY }: any\n  ) {\n    const validPointerCount =\n      pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (\n      this.shouldFailUnderCustomCriteria(\n        { ...center, deltaX, deltaY },\n        {\n          maxDeltaX,\n          maxDeltaY,\n          maxDistSq,\n          shouldCancelWhenOutside,\n        }\n      ) ||\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n      (!validPointerCount && this.isGestureRunning)\n    ) {\n      return { failed: true };\n    }\n\n    return { success: validPointerCount };\n  }\n}\n\nexport default DiscreteGestureHandler;\n"]},"metadata":{},"sourceType":"module"}