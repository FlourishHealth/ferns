{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar EventManager = function () {\n  function EventManager(view) {\n    _classCallCheck(this, EventManager);\n    _defineProperty(this, \"view\", void 0);\n    _defineProperty(this, \"pointersInBounds\", []);\n    _defineProperty(this, \"activePointersCounter\", void 0);\n    this.view = view;\n    this.activePointersCounter = 0;\n  }\n  _createClass(EventManager, [{\n    key: \"onPointerDown\",\n    value: function onPointerDown(_event) {}\n  }, {\n    key: \"onPointerAdd\",\n    value: function onPointerAdd(_event) {}\n  }, {\n    key: \"onPointerUp\",\n    value: function onPointerUp(_event) {}\n  }, {\n    key: \"onPointerRemove\",\n    value: function onPointerRemove(_event) {}\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(_event) {}\n  }, {\n    key: \"onPointerLeave\",\n    value: function onPointerLeave(_event) {}\n  }, {\n    key: \"onPointerEnter\",\n    value: function onPointerEnter(_event) {}\n  }, {\n    key: \"onPointerCancel\",\n    value: function onPointerCancel(_event) {}\n  }, {\n    key: \"onPointerOutOfBounds\",\n    value: function onPointerOutOfBounds(_event) {}\n  }, {\n    key: \"onPointerMoveOver\",\n    value: function onPointerMoveOver(_event) {}\n  }, {\n    key: \"onPointerMoveOut\",\n    value: function onPointerMoveOut(_event) {}\n  }, {\n    key: \"setOnPointerDown\",\n    value: function setOnPointerDown(callback) {\n      this.onPointerDown = callback;\n    }\n  }, {\n    key: \"setOnPointerAdd\",\n    value: function setOnPointerAdd(callback) {\n      this.onPointerAdd = callback;\n    }\n  }, {\n    key: \"setOnPointerUp\",\n    value: function setOnPointerUp(callback) {\n      this.onPointerUp = callback;\n    }\n  }, {\n    key: \"setOnPointerRemove\",\n    value: function setOnPointerRemove(callback) {\n      this.onPointerRemove = callback;\n    }\n  }, {\n    key: \"setOnPointerMove\",\n    value: function setOnPointerMove(callback) {\n      this.onPointerMove = callback;\n    }\n  }, {\n    key: \"setOnPointerLeave\",\n    value: function setOnPointerLeave(callback) {\n      this.onPointerLeave = callback;\n    }\n  }, {\n    key: \"setOnPointerEnter\",\n    value: function setOnPointerEnter(callback) {\n      this.onPointerEnter = callback;\n    }\n  }, {\n    key: \"setOnPointerCancel\",\n    value: function setOnPointerCancel(callback) {\n      this.onPointerCancel = callback;\n    }\n  }, {\n    key: \"setOnPointerOutOfBounds\",\n    value: function setOnPointerOutOfBounds(callback) {\n      this.onPointerOutOfBounds = callback;\n    }\n  }, {\n    key: \"setOnPointerMoveOver\",\n    value: function setOnPointerMoveOver(callback) {\n      this.onPointerMoveOver = callback;\n    }\n  }, {\n    key: \"setOnPointerMoveOut\",\n    value: function setOnPointerMoveOut(callback) {\n      this.onPointerMoveOut = callback;\n    }\n  }, {\n    key: \"markAsInBounds\",\n    value: function markAsInBounds(pointerId) {\n      if (this.pointersInBounds.indexOf(pointerId) >= 0) {\n        return;\n      }\n      this.pointersInBounds.push(pointerId);\n    }\n  }, {\n    key: \"markAsOutOfBounds\",\n    value: function markAsOutOfBounds(pointerId) {\n      var index = this.pointersInBounds.indexOf(pointerId);\n      if (index < 0) {\n        return;\n      }\n      this.pointersInBounds.splice(index, 1);\n    }\n  }, {\n    key: \"resetManager\",\n    value: function resetManager() {\n      this.activePointersCounter = 0;\n      this.pointersInBounds = [];\n    }\n  }]);\n  return EventManager;\n}();\nexport { EventManager as default };","map":{"version":3,"sources":["EventManager.ts"],"names":["EventManager","constructor","view","activePointersCounter","onPointerDown","_event","onPointerAdd","onPointerUp","onPointerRemove","onPointerMove","onPointerLeave","onPointerEnter","onPointerCancel","onPointerOutOfBounds","onPointerMoveOver","onPointerMoveOut","setOnPointerDown","callback","setOnPointerAdd","setOnPointerUp","setOnPointerRemove","setOnPointerMove","setOnPointerLeave","setOnPointerEnter","setOnPointerCancel","setOnPointerOutOfBounds","setOnPointerMoveOver","setOnPointerMoveOut","markAsInBounds","pointerId","pointersInBounds","indexOf","push","markAsOutOfBounds","index","splice","resetManager"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\nimport { AdaptedEvent, EventTypes, TouchEventType } from '../interfaces';\n\nexport default abstract class EventManager<T> {\n  protected readonly view: T;\n  protected pointersInBounds: number[] = [];\n  protected activePointersCounter: number;\n\n  constructor(view: T) {\n    this.view = view;\n    this.activePointersCounter = 0;\n  }\n\n  public abstract setListeners(): void;\n  protected abstract mapEvent(\n    event: Event,\n    eventType: EventTypes,\n    index?: number,\n    touchEventType?: TouchEventType\n  ): AdaptedEvent;\n\n  protected onPointerDown(_event: AdaptedEvent): void {}\n  protected onPointerAdd(_event: AdaptedEvent): void {}\n  protected onPointerUp(_event: AdaptedEvent): void {}\n  protected onPointerRemove(_event: AdaptedEvent): void {}\n  protected onPointerMove(_event: AdaptedEvent): void {}\n  protected onPointerLeave(_event: AdaptedEvent): void {} // called only when pointer is pressed (or touching)\n  protected onPointerEnter(_event: AdaptedEvent): void {} // called only when pointer is pressed (or touching)\n  protected onPointerCancel(_event: AdaptedEvent): void {\n    // When pointer cancel is triggered and there are more pointers on the view, only one pointer is cancelled\n    // Because we want all pointers to be cancelled by that event, we are doing it manually by reseting handler and changing activePointersCounter to 0\n    // Events that correspond to removing the pointer (pointerup, touchend) have condition, that they don't perform any action when activePointersCounter\n    // is equal to 0. This prevents counter from going to negative values, when pointers are removed from view after one of them has been cancelled\n  }\n  protected onPointerOutOfBounds(_event: AdaptedEvent): void {}\n  protected onPointerMoveOver(_event: AdaptedEvent): void {}\n  protected onPointerMoveOut(_event: AdaptedEvent): void {}\n\n  public setOnPointerDown(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerDown = callback;\n  }\n  public setOnPointerAdd(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerAdd = callback;\n  }\n  public setOnPointerUp(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerUp = callback;\n  }\n  public setOnPointerRemove(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerRemove = callback;\n  }\n  public setOnPointerMove(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerMove = callback;\n  }\n  public setOnPointerLeave(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerLeave = callback;\n  }\n  public setOnPointerEnter(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerEnter = callback;\n  }\n  public setOnPointerCancel(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerCancel = callback;\n  }\n  public setOnPointerOutOfBounds(\n    callback: (event: AdaptedEvent) => void\n  ): void {\n    this.onPointerOutOfBounds = callback;\n  }\n  public setOnPointerMoveOver(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerMoveOver = callback;\n  }\n  public setOnPointerMoveOut(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerMoveOut = callback;\n  }\n\n  protected markAsInBounds(pointerId: number): void {\n    if (this.pointersInBounds.indexOf(pointerId) >= 0) {\n      return;\n    }\n\n    this.pointersInBounds.push(pointerId);\n  }\n\n  protected markAsOutOfBounds(pointerId: number): void {\n    const index: number = this.pointersInBounds.indexOf(pointerId);\n\n    if (index < 0) {\n      return;\n    }\n\n    this.pointersInBounds.splice(index, 1);\n  }\n\n  public resetManager(): void {\n    // Reseting activePointersCounter is necessary to make gestures such as pinch work properly\n    // There are gestures that end when there is still one active pointer (like pinch/rotation)\n    // When these gestures end, they are reset, but they still receive events from pointer that is active\n    // This causes trouble, since only onPointerDown registers gesture in orchestrator, and while gestures receive\n    // Events from active pointer after they finished, next pointerdown event will be registered as additional pointer, not the first one\n    // This casues trouble like gestures getting stuck in END state, even though they should have gone to UNDETERMINED\n\n    this.activePointersCounter = 0;\n    this.pointersInBounds = [];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}