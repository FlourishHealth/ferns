{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport * as React from \"react\";\nimport { useContext } from \"react\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport Pressable from \"react-native-web/dist/exports/Pressable\";\nimport View from \"react-native-web/dist/exports/View\";\nimport { Portal } from \"react-native-portalize\";\nimport { Text } from \"./Text\";\nimport { ThemeContext } from \"./Theme\";\nvar TOOLTIP_OFFSET = 8;\nvar TOOLTIP_OVERFLOW_PADDING = 20;\nvar overflowLeft = function overflowLeft(x) {\n  return x < TOOLTIP_OVERFLOW_PADDING;\n};\nvar overflowRight = function overflowRight(x) {\n  var _Dimensions$get = Dimensions.get(\"window\"),\n    layoutWidth = _Dimensions$get.width;\n  return x + TOOLTIP_OVERFLOW_PADDING > layoutWidth;\n};\nvar getTooltipPosition = function getTooltipPosition(_ref) {\n  var children = _ref.children,\n    tooltip = _ref.tooltip,\n    measured = _ref.measured,\n    idealDirection = _ref.idealDirection;\n  if (!measured) {\n    console.debug(\"No measurements for child yet, cannot show tooltip yet.\");\n    return {};\n  }\n  var childrenY = children.pageY,\n    childrenHeight = children.height,\n    childrenX = children.pageX,\n    childrenWidth = children.width;\n  var tooltipWidth = tooltip.width,\n    tooltipHeight = tooltip.height;\n  var horizontalCenter = childrenX + childrenWidth / 2;\n  var right = childrenX + childrenWidth + TOOLTIP_OFFSET;\n  var left = childrenX - tooltipWidth - TOOLTIP_OFFSET;\n  var top = childrenY - tooltipHeight - TOOLTIP_OFFSET;\n  var bottom = childrenY + childrenHeight + TOOLTIP_OFFSET;\n  var verticalCenter = top + childrenHeight + TOOLTIP_OFFSET;\n  var overflowTop = top < TOOLTIP_OVERFLOW_PADDING;\n  var overflowBottom = bottom + tooltipHeight + TOOLTIP_OVERFLOW_PADDING > Dimensions.get(\"window\").height;\n  if (idealDirection === \"left\" && !overflowLeft(left)) {\n    return {\n      left: left,\n      top: verticalCenter\n    };\n  } else if (idealDirection === \"right\" && !overflowRight(right + tooltipWidth)) {\n    return {\n      left: right,\n      top: verticalCenter\n    };\n  } else if (idealDirection === \"bottom\" && !overflowBottom && !overflowLeft(horizontalCenter - tooltipWidth) && !overflowRight(horizontalCenter + tooltipWidth)) {\n    return {\n      left: horizontalCenter - tooltipWidth / 2,\n      top: bottom\n    };\n  } else {\n    var y = top;\n    if (idealDirection === \"bottom\" && !overflowBottom || overflowTop) {\n      y = bottom;\n    }\n    if (!overflowLeft(horizontalCenter - tooltipWidth) && !overflowRight(horizontalCenter + tooltipWidth)) {\n      return {\n        left: horizontalCenter - tooltipWidth / 2,\n        top: y\n      };\n    } else if (overflowLeft(horizontalCenter - tooltipWidth)) {\n      return {\n        left: TOOLTIP_OVERFLOW_PADDING,\n        top: y\n      };\n    } else {\n      return {\n        left: Dimensions.get(\"window\").width - TOOLTIP_OVERFLOW_PADDING - tooltipWidth,\n        top: y\n      };\n    }\n  }\n};\nexport var Tooltip = function Tooltip(props) {\n  var _useContext = useContext(ThemeContext),\n    theme = _useContext.theme;\n  var text = props.text,\n    children = props.children,\n    bgColor = props.bgColor,\n    idealDirection = props.idealDirection;\n  var hoverDelay = 500;\n  var hoverEndDelay = 0;\n  var _React$useState = React.useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    visible = _React$useState2[0],\n    setVisible = _React$useState2[1];\n  var _React$useState3 = React.useState({\n      children: {},\n      tooltip: {},\n      measured: false\n    }),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    measurement = _React$useState4[0],\n    setMeasurement = _React$useState4[1];\n  var showTooltipTimer = React.useRef();\n  var hideTooltipTimer = React.useRef();\n  var childrenWrapperRef = React.useRef();\n  var touched = React.useRef(false);\n  var isWeb = Platform.OS === \"web\";\n  React.useEffect(function () {\n    return function () {\n      if (showTooltipTimer.current) {\n        clearTimeout(showTooltipTimer.current);\n      }\n      if (hideTooltipTimer.current) {\n        clearTimeout(hideTooltipTimer.current);\n      }\n    };\n  }, []);\n  var handleOnLayout = function handleOnLayout(_ref2) {\n    var layout = _ref2.nativeEvent.layout;\n    var _a, _b;\n    if ((childrenWrapperRef === null || childrenWrapperRef === void 0 ? void 0 : childrenWrapperRef.current) && !((_a = childrenWrapperRef === null || childrenWrapperRef === void 0 ? void 0 : childrenWrapperRef.current) === null || _a === void 0 ? void 0 : _a.measure)) {\n      console.error(\"Tooltip: childrenWrapperRef does not have a measure method.\");\n      return;\n    } else if (!(childrenWrapperRef === null || childrenWrapperRef === void 0 ? void 0 : childrenWrapperRef.current)) {\n      console.error(\"Tooltip: childrenWrapperRef is null.\");\n    }\n    (_b = childrenWrapperRef === null || childrenWrapperRef === void 0 ? void 0 : childrenWrapperRef.current) === null || _b === void 0 ? void 0 : _b.measure(function (_x, _y, width, height, pageX, pageY) {\n      setMeasurement({\n        children: {\n          pageX: pageX,\n          pageY: pageY,\n          height: height,\n          width: width\n        },\n        tooltip: Object.assign({}, layout),\n        measured: true\n      });\n    });\n  };\n  var handleTouchStart = function handleTouchStart() {\n    if (hideTooltipTimer.current) {\n      clearTimeout(hideTooltipTimer.current);\n    }\n    showTooltipTimer.current = setTimeout(function () {\n      touched.current = true;\n      setVisible(true);\n    }, 100);\n  };\n  var handleHoverIn = function handleHoverIn() {\n    if (hideTooltipTimer.current) {\n      clearTimeout(hideTooltipTimer.current);\n    }\n    showTooltipTimer.current = setTimeout(function () {\n      touched.current = true;\n      setVisible(true);\n    }, hoverDelay);\n  };\n  var handleHoverOut = function handleHoverOut() {\n    touched.current = false;\n    if (showTooltipTimer.current) {\n      clearTimeout(showTooltipTimer.current);\n    }\n    hideTooltipTimer.current = setTimeout(function () {\n      setVisible(false);\n      setMeasurement({\n        children: {},\n        tooltip: {},\n        measured: false\n      });\n    }, hoverEndDelay);\n  };\n  var mobilePressProps = {\n    onPress: React.useCallback(function () {\n      var _a, _b;\n      if (touched.current) {\n        return null;\n      } else {\n        return (_b = (_a = children.props).onClick) === null || _b === void 0 ? void 0 : _b.call(_a);\n      }\n    }, [children.props])\n  };\n  if (!text) {\n    return children;\n  }\n  return React.createElement(React.Fragment, null, visible && (React.createElement(Portal, null, React.createElement(Pressable, {\n    style: Object.assign(Object.assign({\n      alignSelf: \"flex-start\",\n      justifyContent: \"center\",\n      paddingHorizontal: 16,\n      backgroundColor: theme[bgColor !== null && bgColor !== void 0 ? bgColor : \"darkGray\"],\n      borderRadius: 16,\n      paddingVertical: 8,\n      display: \"flex\",\n      flexShrink: 1,\n      maxWidth: Math.max(Dimensions.get(\"window\").width - 32, 300)\n    }, getTooltipPosition(Object.assign(Object.assign({}, measurement), {\n      idealDirection: idealDirection\n    }))), measurement.measured ? {\n      opacity: 1\n    } : {\n      opacity: 0\n    }),\n    testID: \"tooltip-container\",\n    onLayout: handleOnLayout,\n    onPress: function onPress() {\n      setVisible(false);\n    }\n  }, React.createElement(Text, {\n    color: \"white\"\n  }, text)))), React.createElement(View, Object.assign({\n    ref: childrenWrapperRef,\n    onPointerEnter: function onPointerEnter() {\n      var _a, _b;\n      handleHoverIn();\n      (_b = (_a = children.props).onHoverIn) === null || _b === void 0 ? void 0 : _b.call(_a);\n    },\n    onPointerLeave: function onPointerLeave() {\n      var _a, _b;\n      handleHoverOut();\n      (_b = (_a = children.props).onHoverOut) === null || _b === void 0 ? void 0 : _b.call(_a);\n    },\n    onTouchStart: handleTouchStart\n  }, !isWeb && mobilePressProps), children));\n};","map":{"version":3,"sources":["../src/Tooltip.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as React from \"react\";\nimport { useContext } from \"react\";\nimport { Dimensions, Platform, Pressable, View, } from \"react-native\";\nimport { Portal } from \"react-native-portalize\";\nimport { Text } from \"./Text\";\nimport { ThemeContext } from \"./Theme\";\nconst TOOLTIP_OFFSET = 8;\n// How many pixels to leave between the tooltip and the edge of the screen\nconst TOOLTIP_OVERFLOW_PADDING = 20;\nconst overflowLeft = (x) => {\n    return x < TOOLTIP_OVERFLOW_PADDING;\n};\nconst overflowRight = (x) => {\n    const { width: layoutWidth } = Dimensions.get(\"window\");\n    return x + TOOLTIP_OVERFLOW_PADDING > layoutWidth;\n};\nconst getTooltipPosition = ({ children, tooltip, measured, idealDirection, }) => {\n    if (!measured) {\n        console.debug(\"No measurements for child yet, cannot show tooltip yet.\");\n        return {};\n    }\n    const { pageY: childrenY, height: childrenHeight, pageX: childrenX, width: childrenWidth, } = children;\n    const { width: tooltipWidth, height: tooltipHeight } = tooltip;\n    const horizontalCenter = childrenX + childrenWidth / 2;\n    const right = childrenX + childrenWidth + TOOLTIP_OFFSET;\n    const left = childrenX - tooltipWidth - TOOLTIP_OFFSET;\n    const top = childrenY - tooltipHeight - TOOLTIP_OFFSET;\n    const bottom = childrenY + childrenHeight + TOOLTIP_OFFSET;\n    const verticalCenter = top + childrenHeight + TOOLTIP_OFFSET;\n    // Top is overflowed if it would go off either side or the top of the screen.\n    const overflowTop = top < TOOLTIP_OVERFLOW_PADDING;\n    // Bottom is overflowed if it would go off either side or the bottom of the screen.\n    const overflowBottom = bottom + tooltipHeight + TOOLTIP_OVERFLOW_PADDING > Dimensions.get(\"window\").height;\n    // If it would overflow to the right, try to put it above, if not, put it on the left.\n    // If it would overflow to the left, try to put it above, if not, put it to the right.\n    // Happy path:\n    if (idealDirection === \"left\" && !overflowLeft(left)) {\n        return { left, top: verticalCenter };\n    }\n    else if (idealDirection === \"right\" && !overflowRight(right + tooltipWidth)) {\n        return { left: right, top: verticalCenter };\n    }\n    else if (idealDirection === \"bottom\" &&\n        !overflowBottom &&\n        !overflowLeft(horizontalCenter - tooltipWidth) &&\n        !overflowRight(horizontalCenter + tooltipWidth)) {\n        return { left: horizontalCenter - tooltipWidth / 2, top: bottom };\n    }\n    else {\n        // At this point, we're either trying to place it above or below, and force it into the\n        // viewport.\n        let y = top;\n        if ((idealDirection === \"bottom\" && !overflowBottom) || overflowTop) {\n            y = bottom;\n        }\n        // If it fits in the viewport, center it above the child.\n        if (!overflowLeft(horizontalCenter - tooltipWidth) &&\n            !overflowRight(horizontalCenter + tooltipWidth)) {\n            return { left: horizontalCenter - tooltipWidth / 2, top: y };\n        }\n        // Failing that, if it fits on the left, put it there, otherwise to the right.\n        // We know it's smaller than the viewport.\n        else if (overflowLeft(horizontalCenter - tooltipWidth)) {\n            return { left: TOOLTIP_OVERFLOW_PADDING, top: y };\n        }\n        else {\n            return {\n                left: Dimensions.get(\"window\").width - TOOLTIP_OVERFLOW_PADDING - tooltipWidth,\n                top: y,\n            };\n        }\n    }\n};\nexport const Tooltip = (props) => {\n    const { theme } = useContext(ThemeContext);\n    const { text, children, bgColor, idealDirection } = props;\n    const hoverDelay = 500;\n    const hoverEndDelay = 0;\n    const [visible, setVisible] = React.useState(false);\n    const [measurement, setMeasurement] = React.useState({\n        children: {},\n        tooltip: {},\n        measured: false,\n    });\n    const showTooltipTimer = React.useRef();\n    const hideTooltipTimer = React.useRef();\n    const childrenWrapperRef = React.useRef();\n    const touched = React.useRef(false);\n    const isWeb = Platform.OS === \"web\";\n    // If the tooltip is visible, and the user clicks outside of the tooltip, hide it.\n    React.useEffect(() => {\n        return () => {\n            if (showTooltipTimer.current) {\n                clearTimeout(showTooltipTimer.current);\n            }\n            if (hideTooltipTimer.current) {\n                clearTimeout(hideTooltipTimer.current);\n            }\n        };\n    }, []);\n    const handleOnLayout = ({ nativeEvent: { layout } }) => {\n        var _a, _b;\n        if ((childrenWrapperRef === null || childrenWrapperRef === void 0 ? void 0 : childrenWrapperRef.current) && !((_a = childrenWrapperRef === null || childrenWrapperRef === void 0 ? void 0 : childrenWrapperRef.current) === null || _a === void 0 ? void 0 : _a.measure)) {\n            console.error(\"Tooltip: childrenWrapperRef does not have a measure method.\");\n            return;\n        }\n        else if (!(childrenWrapperRef === null || childrenWrapperRef === void 0 ? void 0 : childrenWrapperRef.current)) {\n            console.error(\"Tooltip: childrenWrapperRef is null.\");\n        }\n        (_b = childrenWrapperRef === null || childrenWrapperRef === void 0 ? void 0 : childrenWrapperRef.current) === null || _b === void 0 ? void 0 : _b.measure((_x, _y, width, height, pageX, pageY) => {\n            setMeasurement({\n                children: { pageX, pageY, height, width },\n                tooltip: Object.assign({}, layout),\n                measured: true,\n            });\n        });\n    };\n    const handleTouchStart = () => {\n        if (hideTooltipTimer.current) {\n            clearTimeout(hideTooltipTimer.current);\n        }\n        showTooltipTimer.current = setTimeout(() => {\n            touched.current = true;\n            setVisible(true);\n        }, 100);\n    };\n    const handleHoverIn = () => {\n        if (hideTooltipTimer.current) {\n            clearTimeout(hideTooltipTimer.current);\n        }\n        showTooltipTimer.current = setTimeout(() => {\n            touched.current = true;\n            setVisible(true);\n        }, hoverDelay);\n    };\n    const handleHoverOut = () => {\n        touched.current = false;\n        if (showTooltipTimer.current) {\n            clearTimeout(showTooltipTimer.current);\n        }\n        hideTooltipTimer.current = setTimeout(() => {\n            setVisible(false);\n            setMeasurement({ children: {}, tooltip: {}, measured: false });\n        }, hoverEndDelay);\n    };\n    const mobilePressProps = {\n        onPress: React.useCallback(() => {\n            var _a, _b;\n            if (touched.current) {\n                return null;\n            }\n            else {\n                return (_b = (_a = children.props).onClick) === null || _b === void 0 ? void 0 : _b.call(_a);\n            }\n        }, [children.props]),\n    };\n    // Allow disabling tooltips when there is no string,\n    // otherwise you need to wrap the children in a function to determine if there should be a tooltip\n    // or not, which gets messy.\n    if (!text) {\n        return children;\n    }\n    return (React.createElement(React.Fragment, null,\n        visible && (React.createElement(Portal, null,\n            React.createElement(Pressable, { style: Object.assign(Object.assign({ alignSelf: \"flex-start\", justifyContent: \"center\", paddingHorizontal: 16, backgroundColor: theme[bgColor !== null && bgColor !== void 0 ? bgColor : \"darkGray\"], borderRadius: 16, paddingVertical: 8, display: \"flex\", flexShrink: 1, maxWidth: Math.max(Dimensions.get(\"window\").width - 32, 300) }, getTooltipPosition(Object.assign(Object.assign({}, measurement), { idealDirection }))), (measurement.measured ? { opacity: 1 } : { opacity: 0 })), testID: \"tooltip-container\", onLayout: handleOnLayout, onPress: () => {\n                    setVisible(false);\n                } },\n                React.createElement(Text, { color: \"white\" }, text)))),\n        React.createElement(View, Object.assign({ ref: childrenWrapperRef, onPointerEnter: () => {\n                var _a, _b;\n                handleHoverIn();\n                (_b = (_a = children.props).onHoverIn) === null || _b === void 0 ? void 0 : _b.call(_a);\n            }, onPointerLeave: () => {\n                var _a, _b;\n                handleHoverOut();\n                (_b = (_a = children.props).onHoverOut) === null || _b === void 0 ? void 0 : _b.call(_a);\n            }, onTouchStart: handleTouchStart }, (!isWeb && mobilePressProps)), children)));\n};\n//# sourceMappingURL=Tooltip.js.map"]},"metadata":{},"sourceType":"module"}