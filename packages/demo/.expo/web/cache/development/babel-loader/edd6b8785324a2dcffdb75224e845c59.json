{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport React, { Children, Component, createContext, useEffect, useRef } from 'react';\nimport { setShouldAnimateExitingForTag } from '../core';\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nexport var SkipEnteringContext = createContext(null);\nfunction SkipEntering(props) {\n  var skipValueRef = useRef(props.shouldSkip);\n  useEffect(function () {\n    skipValueRef.current = false;\n  }, [skipValueRef]);\n  return React.createElement(SkipEnteringContext.Provider, {\n    value: skipValueRef\n  }, props.children);\n}\nexport var LayoutAnimationConfig = function (_Component) {\n  _inherits(LayoutAnimationConfig, _Component);\n  var _super = _createSuper(LayoutAnimationConfig);\n  function LayoutAnimationConfig() {\n    _classCallCheck(this, LayoutAnimationConfig);\n    return _super.apply(this, arguments);\n  }\n  _createClass(LayoutAnimationConfig, [{\n    key: \"getMaybeWrappedChildren\",\n    value: function getMaybeWrappedChildren() {\n      return Children.count(this.props.children) > 1 && this.props.skipExiting ? Children.map(this.props.children, function (child) {\n        return React.createElement(LayoutAnimationConfig, {\n          skipExiting: true\n        }, child);\n      }) : this.props.children;\n    }\n  }, {\n    key: \"setShouldAnimateExiting\",\n    value: function setShouldAnimateExiting() {\n      if (Children.count(this.props.children) === 1) {\n        var tag = findNodeHandle(this);\n        if (tag) {\n          setShouldAnimateExitingForTag(tag, !this.props.skipExiting);\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.props.skipExiting !== undefined) {\n        this.setShouldAnimateExiting();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.getMaybeWrappedChildren();\n      if (this.props.skipEntering === undefined) {\n        return children;\n      }\n      return React.createElement(SkipEntering, {\n        shouldSkip: this.props.skipEntering\n      }, children);\n    }\n  }]);\n  return LayoutAnimationConfig;\n}(Component);","map":{"version":3,"sources":["LayoutAnimationConfig.tsx"],"names":["React","Children","Component","createContext","useEffect","useRef","setShouldAnimateExitingForTag","SkipEnteringContext","SkipEntering","props","skipValueRef","shouldSkip","current","Provider","value","children","LayoutAnimationConfig","getMaybeWrappedChildren","count","skipExiting","map","child","setShouldAnimateExiting","tag","findNodeHandle","componentWillUnmount","undefined","render","skipEntering"],"mappings":"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","sourcesContent":["'use strict';\nimport React, {\n  Children,\n  Component,\n  createContext,\n  useEffect,\n  useRef,\n} from 'react';\nimport type { ReactNode } from 'react';\nimport { setShouldAnimateExitingForTag } from '../core';\nimport { findNodeHandle } from 'react-native';\n\nexport const SkipEnteringContext =\n  createContext<React.MutableRefObject<boolean> | null>(null);\n\n// skipEntering - don't animate entering of children on wrapper mount\n// skipExiting - don't animate exiting of children on wrapper unmount\ninterface LayoutAnimationConfigProps {\n  skipEntering?: boolean;\n  skipExiting?: boolean;\n  children: ReactNode;\n}\n\nfunction SkipEntering(props: { shouldSkip: boolean; children: ReactNode }) {\n  const skipValueRef = useRef(props.shouldSkip);\n\n  useEffect(() => {\n    skipValueRef.current = false;\n  }, [skipValueRef]);\n\n  return (\n    <SkipEnteringContext.Provider value={skipValueRef}>\n      {props.children}\n    </SkipEnteringContext.Provider>\n  );\n}\n\n// skipExiting (unlike skipEntering) cannot be done by conditionally\n// configuring the animation in `createAnimatedComponent`, since at this stage\n// we don't know if the wrapper is going to be unmounted or not.\n// That's why we need to pass the skipExiting flag to the native side\n// when the wrapper is unmounted to prevent the animation.\n// Since `ReactNode` can be a list of nodes, we wrap every child with our wrapper\n// so we are able to access its tag with `findNodeHandle`.\n/**\n * A component that lets you skip entering and exiting animations.\n *\n * @param skipEntering - A boolean indicating whether children's entering animations should be skipped when `LayoutAnimationConfig` is mounted.\n * @param skipExiting - A boolean indicating whether children's exiting animations should be skipped when LayoutAnimationConfig is unmounted.\n * @see https://docs.swmansion.com/react-native-reanimated/docs/layout-animations/layout-animation-config/\n */\nexport class LayoutAnimationConfig extends Component<LayoutAnimationConfigProps> {\n  getMaybeWrappedChildren() {\n    return Children.count(this.props.children) > 1 && this.props.skipExiting\n      ? Children.map(this.props.children, (child) => (\n          <LayoutAnimationConfig skipExiting>{child}</LayoutAnimationConfig>\n        ))\n      : this.props.children;\n  }\n\n  setShouldAnimateExiting() {\n    if (Children.count(this.props.children) === 1) {\n      const tag = findNodeHandle(this);\n      if (tag) {\n        setShouldAnimateExitingForTag(tag, !this.props.skipExiting);\n      }\n    }\n  }\n\n  componentWillUnmount(): void {\n    if (this.props.skipExiting !== undefined) {\n      this.setShouldAnimateExiting();\n    }\n  }\n\n  render(): ReactNode {\n    const children = this.getMaybeWrappedChildren();\n\n    if (this.props.skipEntering === undefined) {\n      return children;\n    }\n\n    return (\n      <SkipEntering shouldSkip={this.props.skipEntering}>\n        {children}\n      </SkipEntering>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}