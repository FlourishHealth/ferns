{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport PointerEventManager from './PointerEventManager';\nimport TouchEventManager from './TouchEventManager';\nimport { State } from '../../State';\nimport { isPointerInBounds as _isPointerInBounds } from '../utils';\nexport var GestureHandlerWebDelegate = function () {\n  function GestureHandlerWebDelegate() {\n    _classCallCheck(this, GestureHandlerWebDelegate);\n    _defineProperty(this, \"view\", void 0);\n    _defineProperty(this, \"gestureHandler\", void 0);\n    _defineProperty(this, \"eventManagers\", []);\n  }\n  _createClass(GestureHandlerWebDelegate, [{\n    key: \"getView\",\n    value: function getView() {\n      return this.view;\n    }\n  }, {\n    key: \"init\",\n    value: function init(viewRef, handler) {\n      var _this = this;\n      if (!viewRef) {\n        throw new Error(`Cannot find HTML Element for handler ${handler.getTag()}`);\n      }\n      this.gestureHandler = handler;\n      this.view = findNodeHandle(viewRef);\n      this.view.style['touchAction'] = 'none';\n      this.view.style['WebkitTouchCallout'] = 'none';\n      var config = handler.getConfig();\n      if (!config.userSelect) {\n        this.view.style['webkitUserSelect'] = 'none';\n        this.view.style['userSelect'] = 'none';\n      } else {\n        this.view.style['webkitUserSelect'] = config.userSelect;\n        this.view.style['userSelect'] = config.userSelect;\n      }\n      this.eventManagers.push(new PointerEventManager(this.view));\n      this.eventManagers.push(new TouchEventManager(this.view));\n      this.eventManagers.forEach(function (manager) {\n        return _this.gestureHandler.attachEventManager(manager);\n      });\n    }\n  }, {\n    key: \"isPointerInBounds\",\n    value: function isPointerInBounds(_ref) {\n      var x = _ref.x,\n        y = _ref.y;\n      return _isPointerInBounds(this.view, {\n        x: x,\n        y: y\n      });\n    }\n  }, {\n    key: \"measureView\",\n    value: function measureView() {\n      var rect = this.view.getBoundingClientRect();\n      return {\n        pageX: rect.left,\n        pageY: rect.top,\n        width: rect.width,\n        height: rect.height\n      };\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.eventManagers.forEach(function (manager) {\n        return manager.resetManager();\n      });\n    }\n  }, {\n    key: \"tryResetCursor\",\n    value: function tryResetCursor() {\n      var config = this.gestureHandler.getConfig();\n      if (config.activeCursor && config.activeCursor !== 'auto' && this.gestureHandler.getState() === State.ACTIVE) {\n        this.view.style.cursor = 'auto';\n      }\n    }\n  }, {\n    key: \"onBegin\",\n    value: function onBegin() {}\n  }, {\n    key: \"onActivate\",\n    value: function onActivate() {\n      var config = this.gestureHandler.getConfig();\n      if ((!this.view.style.cursor || this.view.style.cursor === 'auto') && config.activeCursor) {\n        this.view.style.cursor = config.activeCursor;\n      }\n    }\n  }, {\n    key: \"onEnd\",\n    value: function onEnd() {\n      this.tryResetCursor();\n    }\n  }, {\n    key: \"onCancel\",\n    value: function onCancel() {\n      this.tryResetCursor();\n    }\n  }, {\n    key: \"onFail\",\n    value: function onFail() {\n      this.tryResetCursor();\n    }\n  }]);\n  return GestureHandlerWebDelegate;\n}();","map":{"version":3,"sources":["GestureHandlerWebDelegate.ts"],"names":["PointerEventManager","TouchEventManager","State","isPointerInBounds","GestureHandlerWebDelegate","getView","view","init","viewRef","handler","Error","getTag","gestureHandler","findNodeHandle","style","config","getConfig","userSelect","eventManagers","push","forEach","manager","attachEventManager","x","y","measureView","rect","getBoundingClientRect","pageX","left","pageY","top","width","height","reset","resetManager","tryResetCursor","activeCursor","getState","ACTIVE","cursor","onBegin","onActivate","onEnd","onCancel","onFail"],"mappings":"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","sourcesContent":["import { findNodeHandle } from 'react-native';\nimport type GestureHandler from '../handlers/GestureHandler';\nimport {\n  GestureHandlerDelegate,\n  MeasureResult,\n} from './GestureHandlerDelegate';\nimport PointerEventManager from './PointerEventManager';\nimport TouchEventManager from './TouchEventManager';\nimport { State } from '../../State';\nimport { isPointerInBounds } from '../utils';\nimport EventManager from './EventManager';\n\nexport class GestureHandlerWebDelegate\n  implements GestureHandlerDelegate<HTMLElement>\n{\n  private view!: HTMLElement;\n  private gestureHandler!: GestureHandler;\n  private eventManagers: EventManager<unknown>[] = [];\n\n  getView(): HTMLElement {\n    return this.view;\n  }\n\n  init(viewRef: number, handler: GestureHandler): void {\n    if (!viewRef) {\n      throw new Error(\n        `Cannot find HTML Element for handler ${handler.getTag()}`\n      );\n    }\n\n    this.gestureHandler = handler;\n    this.view = findNodeHandle(viewRef) as unknown as HTMLElement;\n\n    this.view.style['touchAction'] = 'none';\n    //@ts-ignore This one disables default events on Safari\n    this.view.style['WebkitTouchCallout'] = 'none';\n\n    const config = handler.getConfig();\n\n    if (!config.userSelect) {\n      this.view.style['webkitUserSelect'] = 'none';\n      this.view.style['userSelect'] = 'none';\n    } else {\n      this.view.style['webkitUserSelect'] = config.userSelect;\n      this.view.style['userSelect'] = config.userSelect;\n    }\n\n    this.eventManagers.push(new PointerEventManager(this.view));\n    this.eventManagers.push(new TouchEventManager(this.view));\n\n    this.eventManagers.forEach((manager) =>\n      this.gestureHandler.attachEventManager(manager)\n    );\n  }\n\n  isPointerInBounds({ x, y }: { x: number; y: number }): boolean {\n    return isPointerInBounds(this.view, { x, y });\n  }\n\n  measureView(): MeasureResult {\n    const rect = this.view.getBoundingClientRect();\n\n    return {\n      pageX: rect.left,\n      pageY: rect.top,\n      width: rect.width,\n      height: rect.height,\n    };\n  }\n\n  reset(): void {\n    this.eventManagers.forEach((manager: EventManager<unknown>) =>\n      manager.resetManager()\n    );\n  }\n\n  tryResetCursor() {\n    const config = this.gestureHandler.getConfig();\n\n    if (\n      config.activeCursor &&\n      config.activeCursor !== 'auto' &&\n      this.gestureHandler.getState() === State.ACTIVE\n    ) {\n      this.view.style.cursor = 'auto';\n    }\n  }\n\n  onBegin(): void {\n    // no-op for now\n  }\n\n  onActivate(): void {\n    const config = this.gestureHandler.getConfig();\n\n    if (\n      (!this.view.style.cursor || this.view.style.cursor === 'auto') &&\n      config.activeCursor\n    ) {\n      this.view.style.cursor = config.activeCursor;\n    }\n  }\n\n  onEnd(): void {\n    this.tryResetCursor();\n  }\n\n  onCancel(): void {\n    this.tryResetCursor();\n  }\n\n  onFail(): void {\n    this.tryResetCursor();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}